blueprint:
  name: "Dreame Vacuum Multi-Button Control"
  description: >
    **Version: 0.3.3 (Alpha - Schedule Integration)**


    Multi-floor control for Dreame vacuum cleaners with schedule integration and notification-based preparation workflow.


    **Core Features:**

    ‚Ä¢ Zero configuration - Select vacuum entity, all else auto-detected

    ‚Ä¢ Per-map schedules - Separate sweep/mop schedules for each map (3 maps supported)

    ‚Ä¢ Automatic base station detection - Maps with base station start automatically

    ‚Ä¢ Notification workflow - Maps without base station send preparation notifications with action buttons

    ‚Ä¢ Flexible triggers - MQTT, Device, State, or Event per function

    ‚Ä¢ Intelligent start/pause/resume with base station detection

    ‚Ä¢ Room/segment cleaning with configurable repeat counts per map


    **Schedule Integration (NEW in v0.3.3):**

    ‚Ä¢ Per-map sweep + mop schedules (6 schedules total)

    ‚Ä¢ Conflict detection - Only 1 schedule runs at a time

    ‚Ä¢ Maps WITH base station ‚Üí Start cleaning automatically

    ‚Ä¢ Maps WITHOUT base station ‚Üí Send notification with "Prepare Robot" button

    ‚Ä¢ Template-based notifications with customizable messages and action buttons

    ‚Ä¢ Repeat notifications (1-3 times, configurable interval)


    **Manual Control Functions:**

    ‚Ä¢ Mode switching (sweep only / sweep + mop)

    ‚Ä¢ Smart start/pause/resume

    ‚Ä¢ Map switching (Map 1, Map 2, Map 3)


    **Requirements:**

    ‚Ä¢ Home Assistant ‚â• 2024.10.0

    ‚Ä¢ Dreame Vacuum Integration ‚â• v2.0.0b19

    ‚Ä¢ At least one saved map configured

    ‚Ä¢ Optional: Schedule Helpers for time-based automation


    üìñ [Documentation](https://github.com/errormastern/dreame-multifloor-control)
  domain: automation
  homeassistant:
    min_version: 2024.10.0
  source_url: https://github.com/errormastern/dreame-multifloor-control/blob/main/vacuum_control.yaml
  input:
    # ========================================
    # ROBOT CONFIGURATION
    # ========================================
    robot_config:
      name: "Robot Configuration"
      description: "Select your Dreame vacuum robot and configure transport behavior. All entity references are auto-detected."
      icon: mdi:robot-vacuum
      collapsed: true
      input:
        vacuum_entity:
          name: "Vacuum Entity"
          description: "Main vacuum entity (e.g., vacuum.dreame_x10). Status, mode, map entities are auto-detected."
          selector:
            entity:
              filter:
                - domain: vacuum
              multiple: false

        pause_delay_after_undock:
          name: "Pause Delay After Undocking"
          description: "Time (seconds) to wait after robot leaves charging station before pausing for manual transport. Allows robot to move slightly away from station for easier pickup. Set to 0 for immediate pause, 2-3s recommended for easier access. Only applies to non-base station maps."
          selector:
            number:
              min: 0.0
              max: 5.0
              step: 0.1
              unit_of_measurement: "s"
              mode: slider
          default: 2.0

    # ========================================
    # MAP 1 CONFIGURATION
    # ========================================
    map_1_config:
      name: "Map 1"
      description: "Configure Map 1: button trigger, cleaning settings, and schedules (map name auto-detected)"
      icon: mdi:home-floor-1
      collapsed: true
      input:
        map1_trigger:
          name: "Map Switch Trigger"
          description: "Trigger to switch to Map 1. MQTT/Device triggers auto-detect action. For State/Event triggers: Set Trigger ID to `fn_map1` in advanced options."
          selector:
            trigger:
          default: []

        map_1_cleaning_repeats:
          name: "Cleaning Repeats"
          description: "Number of cleaning passes for this map (1-3). Higher values for intensive cleaning."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_1_sweep_schedule:
          name: "Sweep-Only Schedule (Optional)"
          description: "Schedule helper for automatic sweep-only cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_1_mop_schedule:
          name: "Sweep+Mop Schedule (Optional)"
          description: "Schedule helper for automatic sweep+mop cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # MAP 2 CONFIGURATION
    # ========================================
    map_2_config:
      name: "Map 2"
      description: "Configure Map 2: button trigger, cleaning settings, and schedules (map name auto-detected)"
      icon: mdi:home-floor-2
      collapsed: true
      input:
        map2_trigger:
          name: "Map Switch Trigger"
          description: "Trigger to switch to Map 2. MQTT/Device triggers auto-detect action. For State/Event triggers: Set Trigger ID to `fn_map2` in advanced options."
          selector:
            trigger:
          default: []

        map_2_cleaning_repeats:
          name: "Cleaning Repeats"
          description: "Number of cleaning passes for this map (1-3). Higher values for intensive cleaning."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_2_sweep_schedule:
          name: "Sweep-Only Schedule (Optional)"
          description: "Schedule helper for automatic sweep-only cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_2_mop_schedule:
          name: "Sweep+Mop Schedule (Optional)"
          description: "Schedule helper for automatic sweep+mop cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # MAP 3 CONFIGURATION
    # ========================================
    map_3_config:
      name: "Map 3"
      description: "Configure Map 3: button trigger, cleaning settings, and schedules (map name auto-detected)"
      icon: mdi:home-floor-3
      collapsed: true
      input:
        map3_trigger:
          name: "Map Switch Trigger"
          description: "Trigger to switch to Map 3. MQTT/Device triggers auto-detect action. For State/Event triggers: Set Trigger ID to `fn_map3` in advanced options."
          selector:
            trigger:
          default: []

        map_3_cleaning_repeats:
          name: "Cleaning Repeats"
          description: "Number of cleaning passes for this map (1-3). Higher values for intensive cleaning."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_3_sweep_schedule:
          name: "Sweep-Only Schedule (Optional)"
          description: "Schedule helper for automatic sweep-only cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_3_mop_schedule:
          name: "Sweep+Mop Schedule (Optional)"
          description: "Schedule helper for automatic sweep+mop cleaning on this map. Create schedule helper first, then select here. Leave as default (none) to disable scheduled cleaning."
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # CONTROL FUNCTIONS
    # ========================================
    control_functions:
      name: "Control Functions"
      description: "Configure triggers for mode switching and cleaning control (buttons, schedules, automations, etc.)"
      icon: mdi:gesture-tap-button
      collapsed: true
      input:
        sweep_trigger:
          name: "Sweep Only Mode Trigger"
          description: "Set vacuum to sweep-only mode (no mopping). MQTT/Device triggers auto-detect action. ‚ö†Ô∏è For State/Event triggers: Set Trigger ID to `fn_sweep` in advanced options."
          selector:
            trigger:
          default: []

        mop_trigger:
          name: "Sweep + Mop Mode Trigger"
          description: "Set vacuum to sweep + mop mode (full cleaning). MQTT/Device triggers auto-detect action. ‚ö†Ô∏è For State/Event triggers: Set Trigger ID to `fn_mop` in advanced options."
          selector:
            trigger:
          default: []

        start_trigger:
          name: "Smart Start/Pause/Resume Trigger"
          description: "Intelligent control: Start when idle, pause when cleaning, resume when paused. MQTT/Device triggers auto-detect action. ‚ö†Ô∏è For State/Event triggers: Set Trigger ID to `fn_start` in advanced options."
          selector:
            trigger:
          default: []

    # ========================================
    # SCHEDULED CLEANING NOTIFICATIONS
    # ========================================
    scheduled_notification_config:
      name: "Scheduled Cleaning Notifications"
      description: "Notifications when schedule triggers on maps without base station. User can start preparation process via button, then robot moves to waiting position."
      icon: mdi:calendar-clock
      collapsed: true
      input:
        scheduled_notification_enabled:
          name: "Enable Notifications"
          description: "Send notification when schedule triggers on a map without base station. 'Prepare Robot' button starts the preparation process (robot moves to waiting position), then Pickup Notification follows."
          selector:
            boolean:
          default: false

        scheduled_notification_service:
          name: "Notification Service"
          description: "Service for sending notifications (e.g., notify.notify, notify.mobile_app_iphone). Check your notification services in Developer Tools ‚Üí Services."
          selector:
            text:
          default: "notify.notify"

        scheduled_notification_title:
          name: "Title"
          description: "Notification title. Supports templates. Available variables: {{ robot_name }}, {{ map_name }}, {{ cleaning_mode_display }}, {{ schedule_name }}, {{ current_time }}, {{ repeat_number }}"
          selector:
            text:
          default: "Scheduled Cleaning Ready"

        scheduled_notification_message:
          name: "Message"
          description: "Notification message body. Supports templates. Available variables: {{ robot_name }}, {{ map_name }}, {{ cleaning_mode_display }}, {{ schedule_name }}, {{ current_time }}, {{ wait_minutes }}, {{ repeat_number }}"
          selector:
            text:
              multiline: true
          default: "{{ robot_name }} is ready for scheduled cleaning on {{ map_name }} ({{ cleaning_mode_display }}). Please prepare the robot."

        scheduled_notification_repeat_count:
          name: "Repeat Count"
          description: "Number of times to repeat the notification if no action is taken (1-3). Stops after user clicks a button or max repeats reached."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
          default: 2

        scheduled_notification_repeat_interval:
          name: "Repeat Interval"
          description: "Wait time (minutes) before sending the next reminder (0-240). Set to 0 to disable repeats."
          selector:
            number:
              min: 0
              max: 240
              step: 5
              unit_of_measurement: "min"
              mode: slider
          default: 15

        scheduled_notification_action1_name:
          name: "Prepare Button Name"
          description: "Button name for 'Prepare Robot' action (stops repeats, waits for manual resume). Action ID: PREPARE_ROBOT"
          selector:
            text:
          default: "Prepare Robot"

        scheduled_notification_action2_name:
          name: "Skip Button Name"
          description: "Button name for 'Skip Cleaning' action (cancels this scheduled cleaning, no repeats). Action ID: SKIP_CLEANING"
          selector:
            text:
          default: "Skip Cleaning"

        scheduled_notification_data:
          name: "Advanced Data (Optional)"
          description: "YAML data for iOS/Android-specific features (e.g., critical alerts, sounds, icons). Leave empty for standard notifications. Example for iOS critical: push:\n  sound:\n    name: default\n    critical: 1\n    volume: 1.0"
          selector:
            text:
              multiline: true
          default: ""

    # ========================================
    # PICKUP NOTIFICATIONS
    # ========================================
    pickup_notification_config:
      name: "Pickup Notifications"
      description: "Notifications when robot is paused and ready for transport. Supports template variables for customization."
      icon: mdi:robot-vacuum-alert
      collapsed: true
      input:
        pickup_notification_enabled:
          name: "Enable Notifications"
          description: "Send notification when robot is paused and ready for manual transport to target map."
          selector:
            boolean:
          default: false

        pickup_notification_service:
          name: "Notification Service"
          description: "Service for sending notifications (e.g., notify.notify, notify.mobile_app_iphone). Check your notification services in Developer Tools ‚Üí Services."
          selector:
            text:
          default: "notify.notify"

        pickup_notification_title:
          name: "Title"
          description: "Notification title. Supports templates. Available variables: {{ robot_name }}, {{ map_name }}, {{ current_map }}, {{ cleaning_mode_display }}, {{ current_time }}, {{ repeat_number }}"
          selector:
            text:
          default: "Robot Ready for Transport"

        pickup_notification_message:
          name: "Message"
          description: "Notification message body. Supports templates. Available variables: {{ robot_name }}, {{ map_name }}, {{ current_map }}, {{ cleaning_mode_display }}, {{ current_time }}, {{ wait_minutes }}, {{ repeat_number }}"
          selector:
            text:
              multiline: true
          default: "{{ robot_name }} is paused and ready for transport to {{ map_name }}. Please pick up the robot."

        pickup_notification_repeat_count:
          name: "Repeat Count"
          description: "Number of times to repeat the notification if cleaning not started (1-3). Stops when robot status changes to cleaning or max repeats reached."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
          default: 2

        pickup_notification_repeat_interval:
          name: "Repeat Interval"
          description: "Wait time (minutes) before sending the next reminder if robot not started (0-240). Set to 0 to disable repeats."
          selector:
            number:
              min: 0
              max: 240
              step: 5
              unit_of_measurement: "min"
              mode: slider
          default: 10

        pickup_notification_action1_name:
          name: "Start Button Name"
          description: "Button name for 'Start Cleaning' action (resumes cleaning after transport). Action ID: START_CLEANING"
          selector:
            text:
          default: "Start Cleaning"

        pickup_notification_action2_name:
          name: "Cancel Button Name"
          description: "Button name for 'Cancel Cleaning' action (returns robot to base station). Action ID: CANCEL_CLEANING"
          selector:
            text:
          default: "Cancel Cleaning"

        pickup_notification_data:
          name: "Advanced Data (Optional)"
          description: "YAML data for iOS/Android-specific features (e.g., critical alerts, sounds, icons). Leave empty for standard notifications."
          selector:
            text:
              multiline: true
          default: ""

    # ========================================
    # CLEANING SETTINGS
    # ========================================
    cleaning_settings:
      name: "Cleaning Settings"
      description: "Configure cleaning behavior and segment service"
      icon: mdi:tune
      collapsed: true
      input:
        global_cleaning_repeats:
          name: "Global Cleaning Repeats (Fallback)"
          description: "Default number of cleaning passes per room/segment when per-map repeats are not configured. Only used when segment service is enabled. Per-map repeats take priority. Recommended: 1 for daily, 2 for normal, 3 for intensive cleaning."
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        use_segment_service:
          name: "Use Segment Service"
          description: "Enable room/segment-based cleaning with configurable repeats (uses dreame_vacuum.vacuum_clean_segment). Disable if segments not found or robot doesn't support segment cleaning (falls back to vacuum.start)."
          selector:
            boolean:
          default: true

    # ========================================
    # SECTION F: ADVANCED SETTINGS
    # ========================================
    advanced_settings:
      name: "Advanced Settings"
      description: "Advanced configuration: Mode values, status states, timeouts, and debugging"
      icon: mdi:cog
      collapsed: true
      input:
        # ============================================
        # TIMEOUTS
        # ============================================
        moistening_timeout:
          name: "Moistening Timeout"
          description: "Maximum wait time (seconds) for moistening status. Only relevant if moistening status is configured. Automation continues on timeout (no abort)."
          selector:
            number:
              min: 10
              max: 180
              step: 5
              unit_of_measurement: "s"
              mode: slider
          default: 60

        start_timeout:
          name: "Start Timeout"
          description: "Maximum wait time (seconds) until robot reaches cleaning status. Required for map switching to wait before pausing for manual transport. Automation aborts on timeout."
          selector:
            number:
              min: 30
              max: 300
              step: 10
              unit_of_measurement: "s"
              mode: slider
          default: 120

        undocking_timeout:
          name: "Undocking Timeout"
          description: "Maximum wait time (seconds) for robot to leave charging station (charging_state = off). Only applies to non-base station maps with sweep+mop mode. Automation continues on timeout (pause immediately)."
          selector:
            number:
              min: 10
              max: 60
              step: 5
              unit_of_measurement: "s"
              mode: slider
          default: 30

        # ============================================
        # MODE VALUES
        # ============================================
        sweeping_mode_value:
          name: "Mode Value: Sweep Only"
          description: "Exact option value for sweep-only mode in the Cleaning Mode select entity. Case-sensitive. Check Developer Tools ‚Üí States for available options."
          selector:
            text:
          default: "sweeping"

        sweeping_mopping_mode_value:
          name: "Mode Value: Sweep + Mop"
          description: "Exact option value for sweep and mop mode in the Cleaning Mode select entity. Case-sensitive. Check Developer Tools ‚Üí States for available options."
          selector:
            text:
          default: "sweeping_and_mopping"

        # ============================================
        # STATUS DETECTION
        # ============================================
        cleaning_states:
          name: "Active Cleaning States"
          description: "Comma-separated list of status values that count as active cleaning. Used to detect if robot is working (for pause logic). Only change if your robot reports different status values."
          selector:
            text:
          default: "cleaning,returning,zone_cleaning,room_cleaning,sweeping,mopping,sweeping_and_mopping"

        moistening_status:
          name: "Moistening Status"
          description: "Status during mop pad moistening (e.g., moistening, wetting_mop). Used for sweep+mop on non-base maps: waits for this status before pausing for manual transport. Leave empty if unsure or not applicable."
          selector:
            text:
          default: ""

        paused_state:
          name: "Paused State"
          description: "Status value indicating that the robot is paused. Used for resume logic in smart start/pause function."
          selector:
            text:
          default: "paused"

        # ============================================
        # DEBUG
        # ============================================
        debug_mode:
          name: "Debug Mode"
          description: "Show persistent notification with debug information on every trigger. Displays function, status, map, segments, and variables. Use for troubleshooting, disable after successful setup."
          selector:
            boolean:
          default: false

# ========================================
# TRIGGER CONFIGURATION
# ========================================
# Function-based trigger merging with conditional enabling
# Each function merges its user-configured triggers
triggers:
  # ========================================
  # FALLBACK TRIGGER (Required for blueprint validation)
  # ========================================
  # This trigger ensures the blueprint always has at least one valid trigger
  # It will never actually fire in normal operation
  # User must configure and enable at least one function for the automation to work
  - trigger: event
    event_type: "dreame_blueprint_setup_required"
    id: "setup_required"

  # ========================================
  # FUNCTION 1: Sweep Only Mode
  # ========================================
  - triggers: !input sweep_trigger

  # ========================================
  # FUNCTION 2: Sweep + Mop Mode
  # ========================================
  - triggers: !input mop_trigger

  # ========================================
  # FUNCTION 3: Smart Start/Pause/Resume
  # ========================================
  - triggers: !input start_trigger

  # ========================================
  # FUNCTION 4: Map 1 Switch
  # ========================================
  - triggers: !input map1_trigger

  # ========================================
  # FUNCTION 5: Map 2 Switch
  # ========================================
  - triggers: !input map2_trigger

  # ========================================
  # FUNCTION 6: Map 3 Switch
  # ========================================
  - triggers: !input map3_trigger

  # ========================================
  # SCHEDULE TRIGGERS (Per-Map Scheduled Cleaning)
  # ========================================
  # Note: If schedule input is empty (default), trigger will never fire
  # Map 1 Schedules
  - trigger: state
    entity_id: !input map_1_sweep_schedule
    to: "on"
    id: schedule_map1_sweep

  - trigger: state
    entity_id: !input map_1_mop_schedule
    to: "on"
    id: schedule_map1_mop

  # Map 2 Schedules
  - trigger: state
    entity_id: !input map_2_sweep_schedule
    to: "on"
    id: schedule_map2_sweep

  - trigger: state
    entity_id: !input map_2_mop_schedule
    to: "on"
    id: schedule_map2_mop

  # Map 3 Schedules
  - trigger: state
    entity_id: !input map_3_sweep_schedule
    to: "on"
    id: schedule_map3_sweep

  - trigger: state
    entity_id: !input map_3_mop_schedule
    to: "on"
    id: schedule_map3_mop

  # ========================================
  # NOTIFICATION ACTION TRIGGERS
  # ========================================
  # Triggered by mobile app notification button clicks
  # These handle user responses to notifications (prepare, skip, start, cancel)

  # Scheduled Cleaning Actions
  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_ROBOT"
    id: notification_prepare

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "SKIP_CLEANING"
    id: notification_skip

  # Pickup Actions
  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "START_CLEANING"
    id: notification_start

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "CANCEL_CLEANING"
    id: notification_cancel

# ========================================
# VARIABLEN
# ========================================
variables:
  # Input Werte importieren - Roboter Entit√§ten
  vacuum_entity: !input vacuum_entity

  # ========================================
  # AUTO-DETECTION: Extract base name from vacuum entity
  # ========================================
  # Pattern: vacuum.helene_wischer ‚Üí helene_wischer
  # Schema: [domain].[vacuum_name]_[entity_name]
  vacuum_base_name: "{{ vacuum_entity.split('.')[1] }}"

  # ========================================
  # ACTIVE ENTITIES (Auto-Detected)
  # ========================================
  # These are the active entities used throughout the automation
  status_sensor: "sensor.{{ vacuum_base_name }}_status"
  cleaning_mode_select: "select.{{ vacuum_base_name }}_cleaning_mode"
  selected_map_select: "select.{{ vacuum_base_name }}_selected_map"
  map_camera: "camera.{{ vacuum_base_name }}_map"
  self_clean_switch: "switch.{{ vacuum_base_name }}_self_clean"
  charging_state_sensor: "binary_sensor.{{ vacuum_base_name }}_charging_state"

  # ========================================
  # MAP CONFIGURATION (Fully Auto-Detected)
  # ========================================
  # Auto-detect all map names from map camera entities
  # Format: camera.{robot}_map_1, _map_2, etc.
  # Extracts: custom_name (if set) or map_name (default)

  map_1_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_1' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 1
    {% endif %}

  map_2_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_2' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 2
    {% endif %}

  map_3_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_3' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 3
    {% endif %}

  map_4_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_4' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 4
    {% endif %}

  map_5_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_5' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 5
    {% endif %}

  map_6_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_6' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 6
    {% endif %}

  # Auto-detect base station map by finding map with charger_position attribute
  base_station_map: >
    {% set ns = namespace(found='') %}
    {% for i in range(1, 7) %}
      {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_' ~ i %}
      {% if states(map_entity) not in ['unknown', 'unavailable'] %}
        {% set charger_pos = state_attr(map_entity, 'charger_position') %}
        {% if charger_pos is not none %}
          {% set ns.found = state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {{ ns.found if ns.found != '' else 'Map 1' }}

  # ========================================
  # PER-MAP CONFIGURATION STRUCTURE
  # ========================================
  # Structured configuration for each map with auto-detected features
  # Used for dynamic per-map behavior based on current_map_name
  map_config:
    map_1:
      name: "{{ map_1_name }}"
      cleaning_repeats: !input map_1_cleaning_repeats
      sweep_schedule: !input map_1_sweep_schedule
      mop_schedule: !input map_1_mop_schedule
      # Auto-detected: Base station presence
      has_base_station: "{{ map_1_name == base_station_map }}"
      # Auto-detected: Available segments/rooms for this map
      segments: >
        {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_1' %}
        {% if states(map_entity) not in ['unknown', 'unavailable'] %}
          {% set rooms_raw = state_attr(map_entity, 'rooms') %}
          {% set segments_raw = state_attr(map_entity, 'segments') %}
          {% if rooms_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, room in rooms_raw.items() %}
              {% if room.room_id is defined %}
                {% set ns.ids = ns.ids + [room.room_id] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% elif segments_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, segment in segments_raw.items() %}
              {% if segment.segment_id is defined %}
                {% set ns.ids = ns.ids + [segment.segment_id] %}
              {% else %}
                {% set ns.ids = ns.ids + [key | int] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% else %}
            []
          {% endif %}
        {% else %}
          []
        {% endif %}
    map_2:
      name: "{{ map_2_name }}"
      cleaning_repeats: !input map_2_cleaning_repeats
      sweep_schedule: !input map_2_sweep_schedule
      mop_schedule: !input map_2_mop_schedule
      has_base_station: "{{ map_2_name == base_station_map }}"
      segments: >
        {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_2' %}
        {% if states(map_entity) not in ['unknown', 'unavailable'] %}
          {% set rooms_raw = state_attr(map_entity, 'rooms') %}
          {% set segments_raw = state_attr(map_entity, 'segments') %}
          {% if rooms_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, room in rooms_raw.items() %}
              {% if room.room_id is defined %}
                {% set ns.ids = ns.ids + [room.room_id] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% elif segments_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, segment in segments_raw.items() %}
              {% if segment.segment_id is defined %}
                {% set ns.ids = ns.ids + [segment.segment_id] %}
              {% else %}
                {% set ns.ids = ns.ids + [key | int] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% else %}
            []
          {% endif %}
        {% else %}
          []
        {% endif %}
    map_3:
      name: "{{ map_3_name }}"
      cleaning_repeats: !input map_3_cleaning_repeats
      sweep_schedule: !input map_3_sweep_schedule
      mop_schedule: !input map_3_mop_schedule
      has_base_station: "{{ map_3_name == base_station_map }}"
      segments: >
        {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_3' %}
        {% if states(map_entity) not in ['unknown', 'unavailable'] %}
          {% set rooms_raw = state_attr(map_entity, 'rooms') %}
          {% set segments_raw = state_attr(map_entity, 'segments') %}
          {% if rooms_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, room in rooms_raw.items() %}
              {% if room.room_id is defined %}
                {% set ns.ids = ns.ids + [room.room_id] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% elif segments_raw is not none %}
            {% set ns = namespace(ids=[]) %}
            {% for key, segment in segments_raw.items() %}
              {% if segment.segment_id is defined %}
                {% set ns.ids = ns.ids + [segment.segment_id] %}
              {% else %}
                {% set ns.ids = ns.ids + [key | int] %}
              {% endif %}
            {% endfor %}
            {{ ns.ids }}
          {% else %}
            []
          {% endif %}
        {% else %}
          []
        {% endif %}

  # ========================================
  # CLEANING SETTINGS
  # ========================================
  mode_sweeping: !input sweeping_mode_value
  mode_sweeping_mopping: !input sweeping_mopping_mode_value
  # Per-map cleaning repeats take priority, fall back to global setting
  global_cleaning_repeats: !input global_cleaning_repeats
  repeats: "{{ current_map_config.cleaning_repeats | default(global_cleaning_repeats, true) | default(2) }}"
  cleaning_states_raw: !input cleaning_states
  cleaning_states: "{{ cleaning_states_raw.split(',') }}"
  paused_state: !input paused_state
  moistening_status: !input moistening_status
  pause_delay_after_undock: !input pause_delay_after_undock
  start_timeout: !input start_timeout
  moistening_timeout: !input moistening_timeout
  undocking_timeout: !input undocking_timeout
  use_segment_service: !input use_segment_service
  debug_mode: !input debug_mode

  # ========================================
  # NOTIFICATION TEMPLATE VARIABLES
  # ========================================
  # Variables available in notification templates for flexible customization
  robot_name: "{{ vacuum_base_name | replace('_', ' ') | title }}"

  cleaning_mode_display: >
    {% if current_mode == mode_sweeping %}Sweep Only
    {% elif current_mode == mode_sweeping_mopping %}Sweep + Mop
    {% else %}{{ current_mode }}{% endif %}

  current_time: "{{ now().strftime('%H:%M') }}"

  # Notification input imports
  scheduled_notification_enabled: !input scheduled_notification_enabled
  pickup_notification_enabled: !input pickup_notification_enabled

  # ========================================
  # SCHEDULE HANDLING & CONFLICT DETECTION
  # ========================================
  # Import schedule entity references
  map_1_sweep_schedule_entity: !input map_1_sweep_schedule
  map_1_mop_schedule_entity: !input map_1_mop_schedule
  map_2_sweep_schedule_entity: !input map_2_sweep_schedule
  map_2_mop_schedule_entity: !input map_2_mop_schedule
  map_3_sweep_schedule_entity: !input map_3_sweep_schedule
  map_3_mop_schedule_entity: !input map_3_mop_schedule

  # Schedule state checks (empty string if not configured)
  schedule_states: >
    [
      '{{ states(map_1_sweep_schedule_entity) if map_1_sweep_schedule_entity else "" }}',
      '{{ states(map_1_mop_schedule_entity) if map_1_mop_schedule_entity else "" }}',
      '{{ states(map_2_sweep_schedule_entity) if map_2_sweep_schedule_entity else "" }}',
      '{{ states(map_2_mop_schedule_entity) if map_2_mop_schedule_entity else "" }}',
      '{{ states(map_3_sweep_schedule_entity) if map_3_sweep_schedule_entity else "" }}',
      '{{ states(map_3_mop_schedule_entity) if map_3_mop_schedule_entity else "" }}'
    ]

  # Detect if this is a schedule-triggered cleaning
  is_schedule_trigger: >
    {{ trigger.id is defined and trigger.id.startswith('schedule_') }}

  # Conflict detection: Check if another schedule is already running
  # Only 1 schedule can be active at a time (silent abort on conflict)
  schedule_conflict_detected: >
    {% if is_schedule_trigger %}
      {# Check if robot is currently cleaning (excluding paused state) #}
      {% set is_currently_cleaning = states(status_sensor) in cleaning_states and states(status_sensor) != paused_state %}
      {{ is_currently_cleaning }}
    {% else %}
      false
    {% endif %}

  # Current schedule trigger info (for debugging and notification context)
  schedule_trigger_map: >
    {% if trigger.id == 'schedule_map1_sweep' %}1
    {% elif trigger.id == 'schedule_map1_mop' %}1
    {% elif trigger.id == 'schedule_map2_sweep' %}2
    {% elif trigger.id == 'schedule_map2_mop' %}2
    {% elif trigger.id == 'schedule_map3_sweep' %}3
    {% elif trigger.id == 'schedule_map3_mop' %}3
    {% else %}unknown{% endif %}

  schedule_trigger_mode: >
    {% if trigger.id in ['schedule_map1_sweep', 'schedule_map2_sweep', 'schedule_map3_sweep'] %}sweep
    {% elif trigger.id in ['schedule_map1_mop', 'schedule_map2_mop', 'schedule_map3_mop'] %}mop
    {% else %}unknown{% endif %}

  schedule_trigger_map_name: >
    {% if schedule_trigger_map == '1' %}{{ map_1_name }}
    {% elif schedule_trigger_map == '2' %}{{ map_2_name }}
    {% elif schedule_trigger_map == '3' %}{{ map_3_name }}
    {% else %}Unknown{% endif %}

  # ========================================
  # FUNCTION ROUTING (Hybrid: ID, Device Trigger, or MQTT Payload)
  # ========================================
  # Priority 1: User-set trigger.id
  # Priority 2: Device Trigger subtype (Zigbee2MQTT device actions)
  # Priority 3: MQTT payload fallback
  # Result: "fn_sweep", "fn_mop", "fn_start", "fn_map1", "fn_map2", "fn_map3", or "unknown"
  triggered_function: >
    {% if trigger.id is defined and trigger.id != '' %}
      {{ trigger.id }}
    {% elif trigger.platform == 'device' and trigger.subtype is defined %}
      {% set action = trigger.subtype %}
      {% if action == '1_single' %}fn_sweep
      {% elif action == '2_single' %}fn_mop
      {% elif action == '3_single' %}fn_start
      {% elif action == '4_single' %}fn_map1
      {% elif action == '5_single' %}fn_map2
      {% elif action == '6_single' %}fn_map3
      {% else %}unknown{% endif %}
    {% elif trigger.platform == 'mqtt' and trigger.payload_json is defined %}
      {% set action = trigger.payload_json.action | default('') %}
      {% if action == '1_single' %}fn_sweep
      {% elif action == '2_single' %}fn_mop
      {% elif action == '3_single' %}fn_start
      {% elif action == '4_single' %}fn_map1
      {% elif action == '5_single' %}fn_map2
      {% elif action == '6_single' %}fn_map3
      {% else %}unknown{% endif %}
    {% else %}unknown{% endif %}

  # ========================================
  # ENTITY STATE CHECKS
  # ========================================
  current_status: "{{ states(status_sensor) }}"
  current_mode: "{{ states(cleaning_mode_select) }}"
  current_map_name: "{{ states(selected_map_select) }}"
  current_map_id: "{{ state_attr(selected_map_select, 'map_id') }}"

  # ========================================
  # CURRENT MAP CONTEXT (Dynamic Lookup)
  # ========================================
  # Dynamically select map config based on current_map_name
  # Used throughout actions for per-map behavior
  current_map_config: >
    {% if current_map_name == map_1_name %}
      {{ map_config.map_1 }}
    {% elif current_map_name == map_2_name %}
      {{ map_config.map_2 }}
    {% elif current_map_name == map_3_name %}
      {{ map_config.map_3 }}
    {% else %}
      {{ map_config.map_1 }}
    {% endif %}

  # Boolean Evaluations (backward-compatible with per-map config)
  is_base_station_map: "{{ current_map_config.has_base_station | default(current_map_name == base_station_map) }}"
  is_cleaning: "{{ current_status in cleaning_states }}"
  is_paused: "{{ current_status == paused_state }}"

  # Room/Segment Data Processing (Hybrid: supports both rooms and segments)
  # Priority 1: rooms (extract room_id values)
  # Priority 2: segments (extract segment_id or keys)
  map_rooms_raw: "{{ state_attr(map_camera, 'rooms') }}"
  map_segments_raw: "{{ state_attr(map_camera, 'segments') }}"

  # Extract room_id values from rooms dict
  room_ids: >
    {% if map_rooms_raw is not none %}
      {% set ns = namespace(ids=[]) %}
      {% for key, room in map_rooms_raw.items() %}
        {% if room.room_id is defined %}
          {% set ns.ids = ns.ids + [room.room_id] %}
        {% endif %}
      {% endfor %}
      {{ ns.ids }}
    {% else %}
      []
    {% endif %}

  # Extract segment_id values from segments dict (fallback)
  segment_ids: >
    {% if map_segments_raw is not none %}
      {% set ns = namespace(ids=[]) %}
      {% for key, segment in map_segments_raw.items() %}
        {% if segment.segment_id is defined %}
          {% set ns.ids = ns.ids + [segment.segment_id] %}
        {% else %}
          {% set ns.ids = ns.ids + [key | int] %}
        {% endif %}
      {% endfor %}
      {{ ns.ids }}
    {% else %}
      []
    {% endif %}

  # Use rooms if available, otherwise use segments (legacy support)
  # NOTE: This is now deprecated in favor of current_map_config.segments
  # Kept for backward compatibility with actions not yet updated
  map_segments_legacy: >
    {% if room_ids | length > 0 %}
      {{ room_ids }}
    {% else %}
      {{ segment_ids }}
    {% endif %}

  # NEW: Use per-map segments from map_config (dynamic lookup)
  map_segments: "{{ current_map_config.segments | default(map_segments_legacy, true) | default([]) }}"

  has_segments: "{{ map_segments | length > 0 }}"
  segments_source: >
    {% if room_ids | length > 0 %}rooms
    {% elif segment_ids | length > 0 %}segments
    {% else %}none{% endif %}

# ========================================
# ACTIONS
# ========================================
actions:
  # ========================================
  # Debug Notification (optional)
  # ========================================
  - if:
      - condition: template
        value_template: "{{ debug_mode }}"
    then:
      - action: persistent_notification.create
        data:
          title: "üîç Debug: Function {{ triggered_function }}"
          message: |
            **Triggered Function:** {{ triggered_function }}
            **Trigger Platform:** {{ trigger.platform }}
            **Trigger ID:** {{ trigger.id | default('N/A') }}
            {% if trigger.platform == 'device' %}
            **Device Trigger Type:** {{ trigger.type | default('N/A') }}
            **Device Trigger Subtype:** {{ trigger.subtype | default('N/A') }}
            {% elif trigger.platform == 'mqtt' %}
            **MQTT Topic:** {{ trigger.topic | default('N/A') }}
            **MQTT Payload:** {{ trigger.payload_json | default('N/A') }}
            {% elif trigger.platform == 'state' %}
            **State Entity:** {{ trigger.entity_id | default('N/A') }}
            **State To:** {{ trigger.to_state.state if trigger.to_state is defined else 'N/A' }}
            {% endif %}

            **Robot Status:** {{ current_status }}
            **Current Map:** {{ current_map_name }} ({{ current_map_id }})
            **Cleaning Mode:** {{ current_mode }}

            **Auto-Detected Maps:**
            ‚Ä¢ Map 1: {{ map_1_name }}
            ‚Ä¢ Map 2: {{ map_2_name }}
            ‚Ä¢ Map 3: {{ map_3_name }}

            **Base Station Map (Auto-Detected):** {{ base_station_map }}
            **Is Current Map Base Station:** {{ is_base_station_map }}

            **Is Cleaning:** {{ is_cleaning }}
            **Is Paused:** {{ is_paused }}

            **Rooms/Segments Available:** {{ has_segments }}
            **Source:** {{ segments_source }}
            **Room/Segment Count:** {{ map_segments | length }}
            **Room/Segment IDs:** {{ map_segments }}

            **--- Per-Map Configuration (v0.3.3 - Schedule Integration) ---**
            **Current Map Config:**
            ‚Ä¢ Map Name: {{ current_map_config.name }}
            ‚Ä¢ Cleaning Repeats: {{ current_map_config.cleaning_repeats }}
            ‚Ä¢ Has Base Station: {{ current_map_config.has_base_station }}
            ‚Ä¢ Segments: {{ current_map_config.segments }}
            ‚Ä¢ Sweep Schedule: {{ current_map_config.sweep_schedule }}
            ‚Ä¢ Mop Schedule: {{ current_map_config.mop_schedule }}

            **All Map Configs:**
            ‚Ä¢ Map 1: {{ map_config.map_1.name }} (Repeats: {{ map_config.map_1.cleaning_repeats }}, Has Base: {{ map_config.map_1.has_base_station }}, Sweep: {{ map_config.map_1.sweep_schedule }}, Mop: {{ map_config.map_1.mop_schedule }})
            ‚Ä¢ Map 2: {{ map_config.map_2.name }} (Repeats: {{ map_config.map_2.cleaning_repeats }}, Has Base: {{ map_config.map_2.has_base_station }}, Sweep: {{ map_config.map_2.sweep_schedule }}, Mop: {{ map_config.map_2.mop_schedule }})
            ‚Ä¢ Map 3: {{ map_config.map_3.name }} (Repeats: {{ map_config.map_3.cleaning_repeats }}, Has Base: {{ map_config.map_3.has_base_station }}, Sweep: {{ map_config.map_3.sweep_schedule }}, Mop: {{ map_config.map_3.mop_schedule }})

            **--- Schedule Information (v0.3.3) ---**
            **Schedule Trigger Detection:**
            ‚Ä¢ Is Schedule Trigger: {{ is_schedule_trigger }}
            ‚Ä¢ Schedule Conflict Detected: {{ schedule_conflict_detected }}
            {% if is_schedule_trigger %}
            **Schedule Trigger Details:**
            ‚Ä¢ Map: {{ schedule_trigger_map_name }}
            ‚Ä¢ Mode: {{ schedule_trigger_mode }}
            ‚Ä¢ Trigger ID: {{ trigger.id }}
            {% endif %}

            **Schedule States:**
            ‚Ä¢ Map 1 Sweep: {{ states(map_1_sweep_schedule_entity) if map_1_sweep_schedule_entity else 'Not configured' }}
            ‚Ä¢ Map 1 Mop: {{ states(map_1_mop_schedule_entity) if map_1_mop_schedule_entity else 'Not configured' }}
            ‚Ä¢ Map 2 Sweep: {{ states(map_2_sweep_schedule_entity) if map_2_sweep_schedule_entity else 'Not configured' }}
            ‚Ä¢ Map 2 Mop: {{ states(map_2_mop_schedule_entity) if map_2_mop_schedule_entity else 'Not configured' }}
            ‚Ä¢ Map 3 Sweep: {{ states(map_3_sweep_schedule_entity) if map_3_sweep_schedule_entity else 'Not configured' }}
            ‚Ä¢ Map 3 Mop: {{ states(map_3_mop_schedule_entity) if map_3_mop_schedule_entity else 'Not configured' }}

            **Notification Configuration:**
            ‚Ä¢ Scheduled Notifications Enabled: {{ scheduled_notification_enabled }}
            ‚Ä¢ Pickup Notifications Enabled: {{ pickup_notification_enabled }}

  # ========================================
  # MAIN LOGIC - Function Routing (by trigger.id)
  # ========================================
  - choose:
      # ========================================
      # SETUP REQUIRED HANDLER
      # ========================================
      # This handles the fallback trigger and shows setup instructions
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'setup_required' }}"
        sequence:
          - action: persistent_notification.create
            data:
              title: "‚ö†Ô∏è Dreame Vacuum Blueprint - Setup Required"
              message: |
                **No functions configured!**

                Please configure your vacuum automation:

                1. **Configure at least one function:**
                   - Add triggers (State/MQTT/Event)
                   - Enable the function toggle

                2. **Available functions:**
                   - üßπ Sweep Only Mode
                   - üíß Sweep + Mop Mode
                   - ‚ñ∂Ô∏è Smart Start/Pause/Resume
                   - üó∫Ô∏è Map 1 / Map 2 / Map 3

                3. **Save your automation** after configuration

                This message appears because the automation has no active triggers configured.

      # ========================================
      # FUNCTION 1: Sweep Only Mode (fn_sweep)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_sweep' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Cleaning Mode Changed"
                  message: "Mode set to: **Sweep Only** ({{ mode_sweeping }})"

      # ========================================
      # FUNCTION 2: Sweep + Mop Mode (fn_mop)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_mop' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping_mopping }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Cleaning Mode Changed"
                  message: "Mode set to: **Sweep + Mop** ({{ mode_sweeping_mopping }})"

      # ========================================
      # FUNCTION 3: Smart Start/Pause/Resume (fn_start)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_start' }}"
        sequence:
          - choose:
              # Robot is cleaning ‚Üí Pause
              - conditions:
                  - condition: template
                    value_template: "{{ is_cleaning }}"
                sequence:
                  - action: vacuum.pause
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è∏Ô∏è Robot Paused"
                          message: "Previous status: {{ current_status }}"

              # Robot is paused ‚Üí Resume
              - conditions:
                  - condition: template
                    value_template: "{{ is_paused }}"
                sequence:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚ñ∂Ô∏è Robot Resumed"
                          message: "Cleaning continues"

            # Default: Robot idle ‚Üí Start Cleaning
            default:
              - choose:
                  # On base station map ‚Üí Start directly
                  - conditions:
                      - condition: template
                        value_template: "{{ is_base_station_map }}"
                    sequence:
                      # Ensure self_clean is ALWAYS ON for base station cleaning
                      # (regardless of sweep-only or sweep+mop mode)
                      - if:
                          - condition: template
                            value_template: "{{ has_value(self_clean_switch) and is_state(self_clean_switch, 'off') }}"
                        then:
                          - action: switch.turn_on
                            target:
                              entity_id: "{{ self_clean_switch }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üîß Self-Clean Enabled"
                                  message: "Self-clean enabled - robot can return to station during cleaning (moistening only if sweep+mop mode)."

                      - if:
                          - condition: template
                            value_template: "{{ use_segment_service and has_segments }}"
                        then:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_segments }}"
                              repeats: "{{ repeats }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üöÄ Segment Cleaning Started"
                                  message: |
                                    Map: {{ current_map_name }}
                                    Segments: {{ map_segments | length }}
                                    Repeats: {{ repeats }}
                        else:
                          - action: vacuum.start
                            target:
                              entity_id: "{{ vacuum_entity }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üöÄ Cleaning Started"
                                  message: |
                                    Map: {{ current_map_name }}
                                    Mode: Full cleaning

                # On other map ‚Üí Start and pause (for manual transport)
                default:
                  # Enable self_clean ONLY for sweep+mop mode (for moistening)
                  # For sweep-only, self_clean stays OFF (no moistening needed)
                  - if:
                      - condition: template
                        value_template: "{{ has_value(self_clean_switch) and current_mode == mode_sweeping_mopping and is_state(self_clean_switch, 'off') }}"
                    then:
                      - action: switch.turn_on
                        target:
                          entity_id: "{{ self_clean_switch }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "üîß Self-Clean Enabled"
                              message: "Preparing robot at station (moistening mops for sweep+mop mode)..."

                  # Initialize timing variables
                  - variables:
                      timing_start_cleaning: "{{ now().timestamp() }}"
                      timing_start_moistening: null
                      timing_start_undocking: null
                      timing_start_delay: null
                      timeout_step: null

                  - if:
                      - condition: template
                        value_template: "{{ use_segment_service and has_segments }}"
                    then:
                      - action: dreame_vacuum.vacuum_clean_segment
                        target:
                          entity_id: "{{ vacuum_entity }}"
                        data:
                          segments: "{{ map_segments }}"
                          repeats: "{{ repeats }}"
                    else:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  # Wait for cleaning status
                  - wait_template: "{{ states(status_sensor) in cleaning_states }}"
                    timeout:
                      seconds: "{{ start_timeout }}"
                    continue_on_timeout: false

                  - variables:
                      timing_end_cleaning: "{{ now().timestamp() }}"
                      duration_start_cleaning: "{{ (timing_end_cleaning - timing_start_cleaning) | round(1) }}"
                      timeout_step: "{{ 'start_cleaning' if not wait.completed else timeout_step }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è±Ô∏è Timing: Start Cleaning"
                          message: "Duration: {{ duration_start_cleaning }}s / {{ start_timeout }}s{{ ' (TIMEOUT)' if not wait.completed else '' }}"

                  # Optional: Wait for moistening (for sweep+mop)
                  - if:
                      - condition: template
                        value_template: "{{ current_mode == mode_sweeping_mopping and moistening_status != '' }}"
                    then:
                      - variables:
                          timing_start_moistening: "{{ now().timestamp() }}"

                      - wait_template: "{{ states(status_sensor) == moistening_status }}"
                        timeout:
                          seconds: "{{ moistening_timeout }}"
                        continue_on_timeout: true

                      - variables:
                          timing_end_moistening: "{{ now().timestamp() }}"
                          duration_moistening: "{{ (timing_end_moistening - timing_start_moistening) | round(1) }}"
                          timeout_step: "{{ 'moistening' if not wait.completed and timeout_step is none else timeout_step }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è±Ô∏è Timing: Moistening"
                              message: "Duration: {{ duration_moistening }}s / {{ moistening_timeout }}s{{ ' (TIMEOUT - continuing)' if not wait.completed else '' }}"

                  # Wait until robot has left charging station
                  - if:
                      - condition: template
                        value_template: "{{ has_value(charging_state_sensor) }}"
                    then:
                      - variables:
                          timing_start_undocking: "{{ now().timestamp() }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è≥ Waiting for Undocking"
                              message: "Waiting for robot to leave charging station..."

                      - wait_template: "{{ is_state(charging_state_sensor, 'off') }}"
                        timeout:
                          seconds: "{{ undocking_timeout }}"
                        continue_on_timeout: true

                      - variables:
                          timing_end_undocking: "{{ now().timestamp() }}"
                          duration_undocking: "{{ (timing_end_undocking - timing_start_undocking) | round(1) }}"
                          timeout_step: "{{ 'undocking' if not wait.completed and timeout_step is none else timeout_step }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è±Ô∏è Timing: Undocking"
                              message: "Duration: {{ duration_undocking }}s / {{ undocking_timeout }}s{{ ' (TIMEOUT - continuing)' if not wait.completed else '' }}"

                  # Optional delay after undocking for easier pickup
                  - if:
                      - condition: template
                        value_template: "{{ pause_delay_after_undock > 0 }}"
                    then:
                      - variables:
                          timing_start_delay: "{{ now().timestamp() }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è±Ô∏è Post-Undock Delay"
                              message: "Waiting {{ pause_delay_after_undock }}s for robot to move away from station..."

                      - delay:
                          seconds: "{{ pause_delay_after_undock }}"

                      - variables:
                          timing_end_delay: "{{ now().timestamp() }}"
                          duration_delay: "{{ (timing_end_delay - timing_start_delay) | round(1) }}"

                  # Pause for manual transport
                  - action: vacuum.pause
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  # Disable self_clean after pause (robot should not return to station)
                  - if:
                      - condition: template
                        value_template: "{{ has_value(self_clean_switch) and is_state(self_clean_switch, 'on') }}"
                    then:
                      - action: switch.turn_off
                        target:
                          entity_id: "{{ self_clean_switch }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "üîß Self-Clean Disabled"
                              message: "Self-clean disabled - robot will not return to station during cleaning."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è∏Ô∏è Robot Paused for Transport"
                          message: |
                            Map: {{ current_map_name }}
                            Please transport the robot to the target map.
                            Press button again to resume.

                      # Timing Summary
                      - action: persistent_notification.create
                        data:
                          title: "üìä Timing Summary - Non-Base Station Start"
                          message: |
                            **Step Durations:**
                            ‚Ä¢ Start ‚Üí Cleaning: {{ duration_start_cleaning }}s / {{ start_timeout }}s{{ ' ‚ö†Ô∏è TIMEOUT' if timeout_step == 'start_cleaning' else ' ‚úÖ' }}
                            {% if timing_start_moistening is not none %}
                            ‚Ä¢ Moistening: {{ duration_moistening }}s / {{ moistening_timeout }}s{{ ' ‚ö†Ô∏è TIMEOUT (continued)' if timeout_step == 'moistening' else ' ‚úÖ' }}
                            {% endif %}
                            {% if timing_start_undocking is not none %}
                            ‚Ä¢ Undocking: {{ duration_undocking }}s / {{ undocking_timeout }}s{{ ' ‚ö†Ô∏è TIMEOUT (continued)' if timeout_step == 'undocking' else ' ‚úÖ' }}
                            {% endif %}
                            {% if timing_start_delay is not none %}
                            ‚Ä¢ Post-Undock Delay: {{ duration_delay }}s
                            {% endif %}

                            **Total Time:** {{ (now().timestamp() - timing_start_cleaning) | round(1) }}s

                            {% if timeout_step is not none %}
                            **‚ö†Ô∏è Timeout Occurred:** {{ timeout_step }}
                            {% else %}
                            **Status:** All steps completed successfully
                            {% endif %}

      # ========================================
      # FUNCTION 4: Map 1 Switch (fn_map1)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map1' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_1_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_1_name }}**"

      # ========================================
      # FUNCTION 5: Map 2 Switch (fn_map2)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map2' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_2_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_2_name }}**"

      # ========================================
      # FUNCTION 6: Map 3 Switch (fn_map3)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map3' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_3_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_3_name }}**"

      # ========================================
      # SCHEDULE-TRIGGERED CLEANING FUNCTIONS
      # ========================================
      # These functions are triggered by schedule entities (state: "on")
      # Workflow:
      # 1. Conflict check (abort if already cleaning)
      # 2. If map has base station ‚Üí Start cleaning immediately
      # 3. If map WITHOUT base station ‚Üí Send notification, wait for user action

      # ========================================
      # SCHEDULE 1: Map 1 Sweep Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map1_sweep' }}"
          - condition: template
            value_template: "{{ map_1_sweep_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 1 Sweep schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping }}"

          # Switch to Map 1
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_1_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_1_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 1 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_1.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_1.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_1.segments }}"
                              repeats: "{{ map_config.map_1.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 1 Sweep Started"
                          message: "Cleaning started on base station map: {{ map_1_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 1 Sweep"
                      message: "Map {{ map_1_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 1 (Sweep)"

      # ========================================
      # SCHEDULE 2: Map 1 Mop Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map1_mop' }}"
          - condition: template
            value_template: "{{ map_1_mop_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 1 Mop schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep + Mop
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping_mopping }}"

          # Switch to Map 1
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_1_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_1_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 1 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_1.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_1.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_1.segments }}"
                              repeats: "{{ map_config.map_1.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 1 Mop Started"
                          message: "Cleaning started on base station map: {{ map_1_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 1 Mop"
                      message: "Map {{ map_1_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 1 (Mop)"

      # ========================================
      # SCHEDULE 3: Map 2 Sweep Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map2_sweep' }}"
          - condition: template
            value_template: "{{ map_2_sweep_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 2 Sweep schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping }}"

          # Switch to Map 2
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_2_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_2_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 2 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_2.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_2.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_2.segments }}"
                              repeats: "{{ map_config.map_2.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 2 Sweep Started"
                          message: "Cleaning started on base station map: {{ map_2_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 2 Sweep"
                      message: "Map {{ map_2_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 2 (Sweep)"

      # ========================================
      # SCHEDULE 4: Map 2 Mop Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map2_mop' }}"
          - condition: template
            value_template: "{{ map_2_mop_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 2 Mop schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep + Mop
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping_mopping }}"

          # Switch to Map 2
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_2_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_2_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 2 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_2.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_2.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_2.segments }}"
                              repeats: "{{ map_config.map_2.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 2 Mop Started"
                          message: "Cleaning started on base station map: {{ map_2_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 2 Mop"
                      message: "Map {{ map_2_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 2 (Mop)"

      # ========================================
      # SCHEDULE 5: Map 3 Sweep Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map3_sweep' }}"
          - condition: template
            value_template: "{{ map_3_sweep_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 3 Sweep schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping }}"

          # Switch to Map 3
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_3_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_3_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 3 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_3.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_3.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_3.segments }}"
                              repeats: "{{ map_config.map_3.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 3 Sweep Started"
                          message: "Cleaning started on base station map: {{ map_3_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 3 Sweep"
                      message: "Map {{ map_3_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 3 (Sweep)"

      # ========================================
      # SCHEDULE 6: Map 3 Mop Schedule
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'schedule_map3_mop' }}"
          - condition: template
            value_template: "{{ map_3_mop_schedule_entity != 'none' }}"
        sequence:
          # Conflict detection: Abort if already cleaning
          - if:
              - condition: template
                value_template: "{{ schedule_conflict_detected }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict Detected"
                      message: "Map 3 Mop schedule skipped - robot is already cleaning."
              - stop: "Schedule conflict - robot already cleaning"

          # Set cleaning mode to Sweep + Mop
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping_mopping }}"

          # Switch to Map 3
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_3_name }}"

          # Wait for map switch
          - wait_template: "{{ states(selected_map_select) == map_3_name }}"
            timeout: 30
            continue_on_timeout: false

          # Check if Map 3 has base station
          - choose:
              # Case A: Map has base station ‚Üí Start cleaning immediately
              - conditions:
                  - condition: template
                    value_template: "{{ map_config.map_3.has_base_station }}"
                sequence:
                  # Start cleaning (segment-based if available)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ use_segment_service and map_config.map_3.segments | length > 0 }}"
                        sequence:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_config.map_3.segments }}"
                              repeats: "{{ map_config.map_3.cleaning_repeats }}"
                    default:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚úÖ Schedule: Map 3 Mop Started"
                          message: "Cleaning started on base station map: {{ map_3_name }}"

            # Case B: Map WITHOUT base station ‚Üí Send notification
            default:
              - if:
                  - condition: template
                    value_template: "{{ scheduled_notification_enabled }}"
                then:
                  # TODO: Send scheduled cleaning notification with prepare button
                  # This will be implemented with repeat logic
                  - action: persistent_notification.create
                    data:
                      title: "üìÖ Scheduled Cleaning Ready: Map 3 Mop"
                      message: "Map {{ map_3_name }} has no base station. Please prepare robot for transport."

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Scheduled Notification Sent"
                          message: "Waiting for user to prepare robot for Map 3 (Mop)"

      # ========================================
      # NOTIFICATION ACTION HANDLERS
      # ========================================
      # These handle user responses from notification action buttons

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare' }}"
        sequence:
          # TODO: Implement preparation process
          # 1. Start robot cleaning
          # 2. Wait for cleaning state
          # 3. Pause robot for transport
          # 4. Send pickup notification
          - action: persistent_notification.create
            data:
              title: "üîÑ Preparing Robot"
              message: "Starting preparation process... (Implementation pending)"

      # ========================================
      # NOTIFICATION ACTION: Skip Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_skip' }}"
        sequence:
          # Skip this scheduled cleaning - no action needed
          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚è≠Ô∏è Scheduled Cleaning Skipped"
                  message: "User skipped scheduled cleaning via notification button."

      # ========================================
      # NOTIFICATION ACTION: Start Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_start' }}"
        sequence:
          # Resume cleaning after transport
          - action: vacuum.start
            target:
              entity_id: "{{ vacuum_entity }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚ñ∂Ô∏è Cleaning Resumed"
                  message: "Robot resumed cleaning after transport."

      # ========================================
      # NOTIFICATION ACTION: Cancel Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_cancel' }}"
        sequence:
          # Check if robot is on base station map
          - choose:
              # If NOT on base station map, switch to it
              - conditions:
                  - condition: template
                    value_template: "{{ current_map_name != base_station_map }}"
                sequence:
                  - action: select.select_option
                    target:
                      entity_id: "{{ selected_map_select }}"
                    data:
                      option: "{{ base_station_map }}"

                  - wait_template: "{{ states(selected_map_select) == base_station_map }}"
                    timeout: 30
                    continue_on_timeout: true

          # Return to dock
          - action: vacuum.return_to_base
            target:
              entity_id: "{{ vacuum_entity }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üè† Returning to Base"
                  message: "Robot cancelled cleaning and returning to base station."

    # Default: Unknown trigger ID (should not happen)
    default:
      - if:
          - condition: template
            value_template: "{{ debug_mode }}"
        then:
          - action: persistent_notification.create
            data:
              title: "‚ö†Ô∏è Unknown Trigger ID"
              message: |
                **Triggered Function:** {{ triggered_function }}
                **Trigger Platform:** {{ trigger.platform }}
                **Trigger Entity:** {{ trigger.entity_id | default('N/A') }}

                This trigger ID is not configured. Please check your function trigger configurations.

# ========================================
# AUTOMATION MODE
# ========================================
mode: queued
max: 10
max_exceeded: silent
