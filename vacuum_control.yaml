blueprint:
  name: "ü§ñ Dreame Vacuum Multi-Button Control"
  description: |
    **Version: 0.5.4**

    Multi-floor control for Dreame vacuum cleaners with simplified, reliable start/pause workflow.
    Intelligent washing detection and configurable delay for easy robot pickup.

    **Main Features:**
    ‚Ä¢ ü§ñ Auto-detection of vacuum entities (select vacuum, rest auto-detected)
    ‚Ä¢ üìÖ Per-map schedules with sweep/mop modes (3 maps, 6 schedules total)
    ‚Ä¢ üîî Notification workflow with action buttons for transport preparation
    ‚Ä¢ ‚è≠Ô∏è Manual control via MQTT, device triggers, state changes, or events
    ‚Ä¢ üó∫Ô∏è Segment-based Map cleaning with configurable repeats

    **Requirements:**
    ‚Ä¢ Home Assistant ‚â• 2024.10.0
    ‚Ä¢ Dreame Vacuum Integration ‚â• v2.0.0b19
    ‚Ä¢ At least one saved map configured
    ‚Ä¢ Optional: Schedule helpers for time-based automation

    üìñ [Full Documentation](https://github.com/errormastern/dreame-multifloor-control)
  domain: automation
  homeassistant:
    min_version: 2024.10.0
  source_url: https://github.com/errormastern/dreame-multifloor-control/blob/main/vacuum_control.yaml
  input:
    # ========================================
    # ROBOT CONFIGURATION
    # ========================================
    robot_config:
      name: "Robot Configuration"
      description: |
        Select your Dreame vacuum and configure transport behavior.
        All related entities (mode, map) are auto-detected, and status is accessed via vacuum entity attributes.
      icon: mdi:robot-vacuum
      collapsed: true
      input:
        vacuum_entity:
          name: "Vacuum Entity"
          description: |
            Select your vacuum entity (e.g., `vacuum.dreame_x10`).
            All other entities are auto-detected from this selection.
          selector:
            entity:
              filter:
                - domain: vacuum
              multiple: false

        pause_delay_after_undock:
          name: "Pause Delay After Start"
          description: |
            Wait time after starting cleaning before pausing for manual transport.
            Allows robot to move away from base station for easier pickup.

            ‚Ä¢ **0s:** Skip start entirely (robot stays docked)
            ‚Ä¢ **1-3s:** Short delay (robot slightly away from dock)
            ‚Ä¢ **4-5s:** Recommended (robot well clear of dock, easy to grab)
            ‚Ä¢ **6-10s:** Extended delay (robot moves further from base station)

            Only applies to non-base station maps.
          selector:
            number:
              min: 0.0
              max: 10.0
              step: 0.5
              unit_of_measurement: "s"
              mode: slider
          default: 4.5

    # ========================================
    # MAP 1 CONFIGURATION
    # ========================================
    map_1_config:
      name: "Map 1"
      description: |
        Configure Map 1: trigger, cleaning settings, and schedules.
        Map name is auto-detected from your vacuum.

        ‚ö†Ô∏è **Trigger ID for State/Event triggers:** `fn_map1`
      icon: mdi:home-floor-1
      collapsed: true
      input:
        map1_trigger:
          name: "Map Switch Trigger"
          description: |
            Trigger to switch to this map.

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_map1`
          selector:
            trigger:
          default: []

        map_1_cleaning_repeats:
          name: "Cleaning Repeats"
          description: |
            Number of cleaning passes per room/segment (1-3).

            ‚Ä¢ **1:** Quick daily cleaning
            ‚Ä¢ **2:** Normal cleaning (recommended)
            ‚Ä¢ **3:** Deep/intensive cleaning
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_1_sweep_schedule:
          name: "üìÖ Sweep-Only Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep-only cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_1_mop_schedule:
          name: "üìÖ Sweep+Mop Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep+mop cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # MAP 2 CONFIGURATION
    # ========================================
    map_2_config:
      name: "Map 2"
      description: |
        Configure Map 2: trigger, cleaning settings, and schedules.
        Map name is auto-detected from your vacuum.

        ‚ö†Ô∏è **Trigger ID for State/Event triggers:** `fn_map2`
      icon: mdi:home-floor-2
      collapsed: true
      input:
        map2_trigger:
          name: "Map Switch Trigger"
          description: |
            Trigger to switch to this map.

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_map2`
          selector:
            trigger:
          default: []

        map_2_cleaning_repeats:
          name: "Cleaning Repeats"
          description: |
            Number of cleaning passes per room/segment (1-3).

            ‚Ä¢ **1:** Quick daily cleaning
            ‚Ä¢ **2:** Normal cleaning (recommended)
            ‚Ä¢ **3:** Deep/intensive cleaning
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_2_sweep_schedule:
          name: "üìÖ Sweep-Only Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep-only cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_2_mop_schedule:
          name: "üìÖ Sweep+Mop Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep+mop cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # MAP 3 CONFIGURATION
    # ========================================
    map_3_config:
      name: "Map 3"
      description: |
        Configure Map 3: trigger, cleaning settings, and schedules.
        Map name is auto-detected from your vacuum.

        ‚ö†Ô∏è **Trigger ID for State/Event triggers:** `fn_map3`
      icon: mdi:home-floor-3
      collapsed: true
      input:
        map3_trigger:
          name: "Map Switch Trigger"
          description: |
            Trigger to switch to this map.

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_map3`
          selector:
            trigger:
          default: []

        map_3_cleaning_repeats:
          name: "Cleaning Repeats"
          description: |
            Number of cleaning passes per room/segment (1-3).

            ‚Ä¢ **1:** Quick daily cleaning
            ‚Ä¢ **2:** Normal cleaning (recommended)
            ‚Ä¢ **3:** Deep/intensive cleaning
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        map_3_sweep_schedule:
          name: "üìÖ Sweep-Only Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep-only cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

        map_3_mop_schedule:
          name: "üìÖ Sweep+Mop Schedule (Optional)"
          description: |
            Schedule helper for automatic sweep+mop cleaning.

            Create schedule helper first (Settings ‚Üí Devices & Services ‚Üí Helpers),
            then select here. Leave as "none" to disable.
          default: "none"
          selector:
            entity:
              filter:
                - domain: schedule

    # ========================================
    # CONTROL FUNCTIONS
    # ========================================
    control_functions:
      name: "Control Functions"
      description: |
        Configure triggers for mode switching and cleaning control.

        ‚ö†Ô∏è **Important for State/Event Triggers:**
        MQTT and Device triggers work automatically.
        For State/Event triggers, you MUST set the **Trigger ID** in advanced options:
        ‚Ä¢ Sweep Mode ‚Üí Trigger ID: `fn_sweep`
        ‚Ä¢ Mop Mode ‚Üí Trigger ID: `fn_mop`
        ‚Ä¢ Start/Pause ‚Üí Trigger ID: `fn_start`
      icon: mdi:gesture-tap-button
      collapsed: true
      input:
        sweep_trigger:
          name: "Sweep Only Mode Trigger"
          description: |
            Switches vacuum to sweep-only mode (no mopping).

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_sweep`
          selector:
            trigger:
          default: []

        mop_trigger:
          name: "Sweep + Mop Mode Trigger"
          description: |
            Switches vacuum to sweep + mop mode (full cleaning).

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_mop`
          selector:
            trigger:
          default: []

        start_trigger:
          name: "Smart Start/Pause/Resume Trigger"
          description: |
            Intelligent control based on robot status:
            ‚Ä¢ Idle ‚Üí Start cleaning
            ‚Ä¢ Cleaning ‚Üí Pause
            ‚Ä¢ Paused ‚Üí Resume

            **MQTT/Device triggers:** Auto-detected
            **State/Event triggers:** Set Trigger ID to `fn_start`
          selector:
            trigger:
          default: []

    # ========================================
    # SCHEDULED CLEANING NOTIFICATIONS
    # ========================================
    scheduled_notification_config:
      name: "Scheduled Cleaning Notifications"
      description: |
        Notifications when schedule triggers on maps without base station.
        User clicks "Prepare Robot" ‚Üí robot moves to waiting position ‚Üí pickup notification follows.
      icon: mdi:calendar-clock
      collapsed: true
      input:
        scheduled_notification_enabled:
          name: "Enable Notifications"
          description: |
            Send notification when schedule triggers on non-base station map.
            "Prepare Robot" button starts preparation workflow.
          selector:
            boolean:
          default: false

        scheduled_notification_service:
          name: "Notification Service"
          description: |
            Service for sending notifications.
            Examples: `notify.notify`, `notify.mobile_app_iphone`

            Check Developer Tools ‚Üí Services for available services.
          selector:
            text:
          default: "notify.notify"

        scheduled_notification_title:
          name: "Title"
          description: |
            Notification title (supports Jinja2 templates).

            **Available variables:** `robot_name`, `map_name`, `cleaning_mode_display`,
            `schedule_name`, `current_time`, `repeat_number`
          selector:
            text:
          default: "Scheduled Cleaning Ready"

        scheduled_notification_message:
          name: "Message"
          description: |
            Notification message body (supports Jinja2 templates).

            **Available variables:** `robot_name`, `map_name`, `cleaning_mode_display`,
            `schedule_name`, `current_time`, `wait_minutes`, `repeat_number`
          selector:
            text:
              multiline: true
          default: "{{ robot_name }} is ready for scheduled cleaning on {{ map_name }} ({{ cleaning_mode_display }}). Please prepare the robot."

        scheduled_notification_repeat_count:
          name: "Repeat Count"
          description: |
            How many times to resend notification if user doesn't respond (1-3).
            Stops when user clicks any button or max repeats reached.
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
          default: 2

        scheduled_notification_repeat_interval:
          name: "Repeat Interval"
          description: |
            Wait time before sending next reminder (0-240 minutes).
            Set to 0 to disable repeats.
          selector:
            number:
              min: 0
              max: 240
              step: 5
              unit_of_measurement: "min"
              mode: slider
          default: 15

        scheduled_notification_interruption_level:
          name: "iOS Interruption Level"
          description: |
            Notification priority level for iOS devices.

            ‚Ä¢ **Passive:** Silent, background only
            ‚Ä¢ **Active:** Standard, shows on lock screen
            ‚Ä¢ **Time-Sensitive:** Bypasses Focus modes
            ‚Ä¢ **Critical:** Always notifies, bypasses Do Not Disturb
          selector:
            select:
              options:
                - label: "Passive (Silent, Background)"
                  value: "passive"
                - label: "Active (Standard, Lock Screen)"
                  value: "active"
                - label: "Time-Sensitive (Bypass Focus)"
                  value: "time-sensitive"
                - label: "Critical (Always Notify)"
                  value: "critical"
          default: "active"

        scheduled_notification_sound:
          name: "iOS Sound"
          description: |
            Sound file name for iOS notifications.
            Examples: `default`, `none`, or custom sound name
          selector:
            text:
          default: "default"

        scheduled_notification_critical:
          name: "iOS Critical Alert"
          description: |
            Enable critical alert (bypasses Do Not Disturb and mute switch).
            Requires special iOS permission. Use only for urgent notifications!
          selector:
            boolean:
          default: false

        scheduled_notification_volume:
          name: "iOS Critical Volume"
          description: |
            Volume for critical alerts (0.0-1.0).
            Only applies when critical alert is enabled.
          selector:
            number:
              min: 0.0
              max: 1.0
              step: 0.1
              mode: slider
          default: 1.0

    # ========================================
    # PICKUP NOTIFICATIONS
    # ========================================
    pickup_notification_config:
      name: "Pickup Notifications"
      description: |
        Notifications when robot is paused and ready for manual transport.
        User transports robot ‚Üí clicks "Start Cleaning" ‚Üí robot resumes.
      icon: mdi:robot-vacuum-alert
      collapsed: true
      input:
        pickup_notification_enabled:
          name: "Enable Notifications"
          description: |
            Send notification when robot is paused and ready for transport.
            User can start cleaning after placing robot on target floor.
          selector:
            boolean:
          default: false

        pickup_notification_service:
          name: "Notification Service"
          description: |
            Service for sending notifications.
            Examples: `notify.notify`, `notify.mobile_app_iphone`

            Check Developer Tools ‚Üí Services for available services.
          selector:
            text:
          default: "notify.notify"

        pickup_notification_title:
          name: "Title"
          description: |
            Notification title (supports Jinja2 templates).

            **Available variables:** `robot_name`, `map_name`, `current_map`,
            `cleaning_mode_display`, `current_time`, `repeat_number`
          selector:
            text:
          default: "Robot Ready for Transport"

        pickup_notification_message:
          name: "Message"
          description: |
            Notification message body (supports Jinja2 templates).

            **Available variables:** `robot_name`, `map_name`, `current_map`,
            `cleaning_mode_display`, `current_time`, `wait_minutes`, `repeat_number`
          selector:
            text:
              multiline: true
          default: "{{ robot_name }} is paused and ready for transport to {{ map_name }}. Please pick up the robot."

        pickup_notification_repeat_count:
          name: "Repeat Count"
          description: |
            How many times to resend notification if robot not started (1-3).
            Stops when cleaning resumes or max repeats reached.
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
          default: 2

        pickup_notification_repeat_interval:
          name: "Repeat Interval"
          description: |
            Wait time before sending next reminder (0-240 minutes).
            Set to 0 to disable repeats.
          selector:
            number:
              min: 0
              max: 240
              step: 5
              unit_of_measurement: "min"
              mode: slider
          default: 10

        pickup_notification_interruption_level:
          name: "iOS Interruption Level"
          description: |
            Notification priority level for iOS devices.

            ‚Ä¢ **Passive:** Silent, background only
            ‚Ä¢ **Active:** Standard, shows on lock screen
            ‚Ä¢ **Time-Sensitive:** Bypasses Focus modes (recommended)
            ‚Ä¢ **Critical:** Always notifies, bypasses Do Not Disturb
          selector:
            select:
              options:
                - label: "Passive (Silent, Background)"
                  value: "passive"
                - label: "Active (Standard, Lock Screen)"
                  value: "active"
                - label: "Time-Sensitive (Bypass Focus)"
                  value: "time-sensitive"
                - label: "Critical (Always Notify)"
                  value: "critical"
          default: "time-sensitive"

        pickup_notification_sound:
          name: "iOS Sound"
          description: |
            Sound file name for iOS notifications.
            Examples: `default`, `none`, or custom sound name
          selector:
            text:
          default: "default"

        pickup_notification_critical:
          name: "iOS Critical Alert"
          description: |
            Enable critical alert (bypasses Do Not Disturb and mute switch).
            Requires special iOS permission. Use only for urgent notifications!
          selector:
            boolean:
          default: false

        pickup_notification_volume:
          name: "iOS Critical Volume"
          description: |
            Volume for critical alerts (0.0-1.0).
            Only applies when critical alert is enabled.
          selector:
            number:
              min: 0.0
              max: 1.0
              step: 0.1
              mode: slider
          default: 1.0

    # ========================================
    # CLEANING SETTINGS
    # ========================================
    cleaning_settings:
      name: "Cleaning Settings"
      description: |
        Configure cleaning behavior and segment-based cleaning.
      icon: mdi:tune
      collapsed: true
      input:
        global_cleaning_repeats:
          name: "Global Cleaning Repeats (Fallback)"
          description: |
            Default cleaning passes per room/segment (1-3).
            Used only when per-map repeats are not configured.

            ‚Ä¢ **1:** Daily cleaning
            ‚Ä¢ **2:** Normal cleaning (recommended)
            ‚Ä¢ **3:** Intensive/deep cleaning

            **Note:** Per-map repeats override this setting.
          selector:
            number:
              min: 1
              max: 3
              step: 1
              mode: slider
              unit_of_measurement: "passes"
          default: 2

        use_segment_service:
          name: "Use Segment Service"
          description: |
            Enable room/segment-based cleaning with configurable repeats.
            Uses `dreame_vacuum.vacuum_clean_segment` service.

            Disable if segments aren't detected or robot doesn't support segment cleaning.
            Falls back to `vacuum.start` when disabled.
          selector:
            boolean:
          default: true

    # ========================================
    # SECTION F: LOCALIZATION
    # ========================================
    localization_config:
      name: "Localization"
      description: |
        Customize display texts for notifications and buttons.
        Perfect for non-English Home Assistant installations.
      icon: mdi:translate
      collapsed: true
      input:
        sweep_display_text:
          name: "Sweep Mode Display Name"
          description: "Display name for sweep-only mode (e.g., 'Saugen' in German)"
          selector:
            text:
          default: "Sweep"

        mop_display_text:
          name: "Mop Mode Display Name"
          description: "Display name for mop-only mode (e.g., 'Wischen' in German)"
          selector:
            text:
          default: "Mop"

        sweep_mop_display_text:
          name: "Combined Mode Display Name"
          description: "Display name for combined sweep+mop mode (e.g., 'Saugen + Wischen' in German)"
          selector:
            text:
          default: "Sweep + Mop"

        prepare_button_text:
          name: "Prepare Button Label"
          description: "Button text for robot preparation (e.g., 'Roboter vorbereiten' in German)"
          selector:
            text:
          default: "Prepare Robot"

        skip_button_text:
          name: "Skip Button Label"
          description: "Button text for skipping cleaning (e.g., 'Reinigung √ºberspringen' in German)"
          selector:
            text:
          default: "Skip Cleaning"

        start_cleaning_button_text:
          name: "Start Cleaning Button Label"
          description: "Button text for starting cleaning (e.g., 'Reinigung starten' in German)"
          selector:
            text:
          default: "Start Cleaning"

        cancel_cleaning_button_text:
          name: "Cancel Button Label"
          description: "Button text for canceling (e.g., 'Abbrechen' in German)"
          selector:
            text:
          default: "Cancel Cleaning"

    # ========================================
    # SECTION G: ADVANCED SETTINGS
    # ========================================
    advanced_settings:
      name: "Advanced Settings"
      description: |
        Advanced configuration: timeouts, mode values, status detection, and debugging.
        Most users can keep the defaults.
      icon: mdi:cog
      collapsed: true
      input:
        # ============================================
        # TIMEOUTS
        # ============================================
        moistening_timeout:
          name: "‚è±Ô∏è Moistening Timeout"
          description: |
            Wait time for self-wash base workflow (mop moistening + water refill).
            Can take 3+ minutes for complete preparation cycle.

            Automation continues on timeout (non-critical).
          selector:
            number:
              min: 10
              max: 300
              step: 5
              unit_of_measurement: "s"
              mode: slider
          default: 180

        sweep_start_timeout:
          name: "‚è±Ô∏è Sweep Start Timeout"
          description: |
            Wait time for sweep-only cleaning to start (5-30 seconds).
            Robot leaves station immediately when sweeping only.

            Fallback timeout if sensor detection fails.
          selector:
            number:
              min: 5
              max: 30
              step: 1
              unit_of_measurement: "s"
              mode: slider
          default: 10

        mop_start_timeout:
          name: "‚è±Ô∏è Mop Start Timeout"
          description: |
            Wait time for sweep+mop cleaning to start (60-180 seconds).
            Includes self-wash base preparation (mop moistening).

            Fallback timeout if sensor detection fails.
          selector:
            number:
              min: 60
              max: 180
              step: 10
              unit_of_measurement: "s"
              mode: slider
          default: 120

        # ============================================
        # MODE VALUES
        # ============================================
        sweeping_mode_value:
          name: "üßπ Mode Value: Sweep Only"
          description: |
            Exact value for sweep-only mode (case-sensitive).

            Check your vacuum's `select.{name}_cleaning_mode` entity in
            Developer Tools ‚Üí States for available options.
          selector:
            text:
          default: "sweeping"

        sweeping_mopping_mode_value:
          name: "üßπ Mode Value: Sweep + Mop"
          description: |
            Exact value for sweep + mop mode (case-sensitive).

            Check your vacuum's `select.{name}_cleaning_mode` entity in
            Developer Tools ‚Üí States for available options.
          selector:
            text:
          default: "sweeping_and_mopping"

        # ============================================
        # STATUS DETECTION
        # ============================================
        cleaning_states:
          name: "üîç Active Cleaning States"
          description: |
            Comma-separated list of status values for active cleaning.
            Used to detect if robot is working (for pause logic).

            Check your vacuum's `sensor.{name}_status` entity for actual values.
            Only change if your robot reports different states.
          selector:
            text:
          default: "cleaning,returning,zone_cleaning,room_cleaning,sweeping,mopping,sweeping_and_mopping"

        moistening_status:
          name: "üîç Moistening Status"
          description: |
            Status value during mop moistening (e.g., `moistening`, `wetting_mop`).
            Used for sweep+mop: waits for this status before pausing for transport.

            Leave empty if unsure or not applicable to your robot.
          selector:
            text:
          default: ""

        paused_state:
          name: "üîç Paused State"
          description: |
            Status value when robot is paused.
            Used for resume logic in smart start/pause function.

            Check your vacuum's `sensor.{name}_status` for actual value.
          selector:
            text:
          default: "paused"

        # ============================================
        # DEBUG
        # ============================================
        debug_mode:
          name: "üêõ Debug Mode"
          description: |
            Show persistent notification with debug info on every trigger.
            Displays: function, status, map, segments, variables.

            Enable for troubleshooting, disable after successful setup.
          selector:
            boolean:
          default: false

# ========================================
# TRIGGER CONFIGURATION
# ========================================
# Function-based trigger merging with conditional enabling
# Each function merges its user-configured triggers
triggers:
  # ========================================
  # FALLBACK TRIGGER (Required for blueprint validation)
  # ========================================
  # This trigger ensures the blueprint always has at least one valid trigger
  # It will never actually fire in normal operation
  # User must configure and enable at least one function for the automation to work
  - trigger: event
    event_type: "dreame_blueprint_setup_required"
    id: "setup_required"

  # ========================================
  # FUNCTION 1: Sweep Only Mode
  # ========================================
  - triggers: !input sweep_trigger

  # ========================================
  # FUNCTION 2: Sweep + Mop Mode
  # ========================================
  - triggers: !input mop_trigger

  # ========================================
  # FUNCTION 3: Smart Start/Pause/Resume
  # ========================================
  - triggers: !input start_trigger

  # ========================================
  # FUNCTION 4: Map 1 Switch
  # ========================================
  - triggers: !input map1_trigger

  # ========================================
  # FUNCTION 5: Map 2 Switch
  # ========================================
  - triggers: !input map2_trigger

  # ========================================
  # FUNCTION 6: Map 3 Switch
  # ========================================
  - triggers: !input map3_trigger

  # ========================================
  # SCHEDULE TRIGGERS (Per-Map Scheduled Cleaning)
  # ========================================
  # Note: If schedule input is empty (default), trigger will never fire
  # Map 1 Schedules
  - trigger: state
    entity_id: !input map_1_sweep_schedule
    to: "on"
    id: schedule_map1_sweep

  - trigger: state
    entity_id: !input map_1_mop_schedule
    to: "on"
    id: schedule_map1_mop

  # Map 2 Schedules
  - trigger: state
    entity_id: !input map_2_sweep_schedule
    to: "on"
    id: schedule_map2_sweep

  - trigger: state
    entity_id: !input map_2_mop_schedule
    to: "on"
    id: schedule_map2_mop

  # Map 3 Schedules
  - trigger: state
    entity_id: !input map_3_sweep_schedule
    to: "on"
    id: schedule_map3_sweep

  - trigger: state
    entity_id: !input map_3_mop_schedule
    to: "on"
    id: schedule_map3_mop

  # ========================================
  # NOTIFICATION ACTION TRIGGERS
  # ========================================
  # Triggered by mobile app notification button clicks
  # These handle user responses to notifications (prepare, skip, start, cancel)

  # Scheduled Cleaning Actions
  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP1_SWEEP"
    id: notification_prepare_map1_sweep

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP1_MOP"
    id: notification_prepare_map1_mop

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP2_SWEEP"
    id: notification_prepare_map2_sweep

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP2_MOP"
    id: notification_prepare_map2_mop

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP3_SWEEP"
    id: notification_prepare_map3_sweep

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "PREPARE_MAP3_MOP"
    id: notification_prepare_map3_mop

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "SKIP_CLEANING"
    id: notification_skip

  # Pickup Actions
  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "START_CLEANING"
    id: notification_start

  - trigger: event
    event_type: mobile_app_notification_action
    event_data:
      action: "CANCEL_CLEANING"
    id: notification_cancel

# ========================================
# VARIABLEN
# ========================================
variables:
  # Input Werte importieren - Roboter Entit√§ten
  vacuum_entity: !input vacuum_entity

  # ========================================
  # AUTO-DETECTION: Extract base name from vacuum entity
  # ========================================
  # Pattern: vacuum.helene_wischer ‚Üí helene_wischer
  # Schema: [domain].[vacuum_name]_[entity_name]
  vacuum_base_name: "{{ vacuum_entity.split('.')[1] }}"

  # ========================================
  # ACTIVE ENTITIES (Auto-Detected)
  # ========================================
  # These are the active entities used throughout the automation
  cleaning_mode_select: "select.{{ vacuum_base_name }}_cleaning_mode"
  selected_map_select: "select.{{ vacuum_base_name }}_selected_map"
  map_camera: "camera.{{ vacuum_base_name }}_map"
  self_clean_switch: "switch.{{ vacuum_base_name }}_self_clean"
  self_clean_button: "button.{{ vacuum_base_name }}_self_clean"
  charging_status_sensor: "sensor.{{ vacuum_base_name }}_charging_status"
  stop_drying_button: "button.{{ vacuum_base_name }}_manual_drying"

  # ========================================
  # MAP CONFIGURATION (Fully Auto-Detected)
  # ========================================
  # Auto-detect all map names from map camera entities
  # Format: camera.{robot}_map_1, _map_2, etc.
  # Extracts: custom_name (if set) or map_name (default)

  map_1_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_1' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 1
    {% endif %}

  map_2_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_2' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 2
    {% endif %}

  map_3_name: >
    {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_3' %}
    {% if states(map_entity) not in ['unknown', 'unavailable'] %}
      {{ state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) }}
    {% else %}
      Map 3
    {% endif %}

  # Auto-detect base station map by finding map with charger_position attribute
  base_station_map: >
    {% set ns = namespace(found='') %}
    {% for i in range(1, 4) %}
      {% set map_entity = 'camera.' ~ vacuum_base_name ~ '_map_' ~ i %}
      {% if states(map_entity) not in ['unknown', 'unavailable'] %}
        {% set charger_pos = state_attr(map_entity, 'charger_position') %}
        {% if charger_pos is not none %}
          {% set ns.found = state_attr(map_entity, 'custom_name') | default(state_attr(map_entity, 'map_name'), true) %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {{ ns.found if ns.found != '' else 'Map 1' }}

  # ========================================
  # PER-MAP CONFIGURATION STRUCTURE
  # ========================================
  # Simple per-map configuration without complex segment pre-calculation
  # Segments are extracted dynamically from current map camera (lazy evaluation)
  # This prevents template rendering errors when camera entities are unavailable
  map_config:
    map_1:
      name: "{{ map_1_name }}"
      cleaning_repeats: !input map_1_cleaning_repeats
      sweep_schedule: !input map_1_sweep_schedule
      mop_schedule: !input map_1_mop_schedule
      has_base_station: "{{ map_1_name == base_station_map }}"
    map_2:
      name: "{{ map_2_name }}"
      cleaning_repeats: !input map_2_cleaning_repeats
      sweep_schedule: !input map_2_sweep_schedule
      mop_schedule: !input map_2_mop_schedule
      has_base_station: "{{ map_2_name == base_station_map }}"
    map_3:
      name: "{{ map_3_name }}"
      cleaning_repeats: !input map_3_cleaning_repeats
      sweep_schedule: !input map_3_sweep_schedule
      mop_schedule: !input map_3_mop_schedule
      has_base_station: "{{ map_3_name == base_station_map }}"

  # ========================================
  # CLEANING SETTINGS (Must be defined BEFORE is_cleaning/is_paused)
  # ========================================
  mode_sweeping: !input sweeping_mode_value
  mode_sweeping_mopping: !input sweeping_mopping_mode_value
  global_cleaning_repeats: !input global_cleaning_repeats
  cleaning_states_raw: !input cleaning_states
  cleaning_states: "{{ cleaning_states_raw.split(',') }}"
  paused_state: !input paused_state

  # ========================================
  # ENTITY STATE CHECKS
  # ========================================
  # IMPORTANT: These must come AFTER cleaning_states/paused_state definition
  current_status: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') }}"
  current_mode: "{{ states(cleaning_mode_select) }}"
  current_map_name: "{{ states(selected_map_select) }}"
  current_map_id: "{{ state_attr(selected_map_select, 'map_id') }}"

  # ========================================
  # CURRENT MAP CONTEXT (Dynamic Lookup)
  # ========================================
  # Dynamically select map config based on current_map_name
  # Robust with fallbacks to prevent undefined errors
  # IMPORTANT: Must come BEFORE variables that use it (like repeats, is_base_station_map)
  current_map_config: "{{ map_config.map_1 if current_map_name == map_1_name else (map_config.map_2 if current_map_name == map_2_name else (map_config.map_3 if current_map_name == map_3_name else map_config.map_1)) }}"

  # Boolean Evaluations with robust defaults
  is_base_station_map: "{{ current_map_config.has_base_station | default(false) if current_map_config is mapping else (current_map_name == base_station_map) }}"
  is_cleaning: "{{ current_status in cleaning_states }}"
  is_paused: "{{ current_status == paused_state }}"

  # Per-map cleaning repeats take priority, fall back to global setting
  repeats: "{{ current_map_config.cleaning_repeats | default(global_cleaning_repeats) | default(2) }}"
  moistening_status: !input moistening_status
  pause_delay_after_undock: !input pause_delay_after_undock
  sweep_start_timeout: !input sweep_start_timeout
  mop_start_timeout: !input mop_start_timeout
  # Dynamic timeout selection based on cleaning mode
  start_timeout: "{{ mop_start_timeout if current_mode == mode_sweeping_mopping else sweep_start_timeout }}"
  moistening_timeout: !input moistening_timeout
  use_segment_service: !input use_segment_service
  debug_mode: !input debug_mode

  # ========================================
  # NOTIFICATION TEMPLATE VARIABLES
  # ========================================
  # Variables available in notification templates for flexible customization
  robot_name: "{{ vacuum_base_name | replace('_', ' ') | title }}"

  cleaning_mode_display: >
    {% if current_mode == mode_sweeping %}{{ sweep_display }}
    {% elif current_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
    {% else %}{{ current_mode }}{% endif %}

  current_time: "{{ now().strftime('%H:%M') }}"

  # Notification input imports
  scheduled_notification_enabled: !input scheduled_notification_enabled
  scheduled_notification_interruption_level: !input scheduled_notification_interruption_level
  scheduled_notification_sound: !input scheduled_notification_sound
  scheduled_notification_critical: !input scheduled_notification_critical
  scheduled_notification_volume: !input scheduled_notification_volume

  pickup_notification_enabled: !input pickup_notification_enabled
  pickup_notification_interruption_level: !input pickup_notification_interruption_level
  pickup_notification_sound: !input pickup_notification_sound
  pickup_notification_critical: !input pickup_notification_critical
  pickup_notification_volume: !input pickup_notification_volume

  # ========================================
  # LOCALIZATION
  # ========================================
  # User-customizable display texts for multilingual notifications
  sweep_display: !input sweep_display_text
  mop_display: !input mop_display_text
  sweep_mop_display: !input sweep_mop_display_text
  prepare_button: !input prepare_button_text
  skip_button: !input skip_button_text
  start_cleaning_button: !input start_cleaning_button_text
  cancel_cleaning_button: !input cancel_cleaning_button_text

  # ========================================
  # SCHEDULE HANDLING & CONFLICT DETECTION
  # ========================================
  # Import schedule entity references
  map_1_sweep_schedule_entity: !input map_1_sweep_schedule
  map_1_mop_schedule_entity: !input map_1_mop_schedule
  map_2_sweep_schedule_entity: !input map_2_sweep_schedule
  map_2_mop_schedule_entity: !input map_2_mop_schedule
  map_3_sweep_schedule_entity: !input map_3_sweep_schedule
  map_3_mop_schedule_entity: !input map_3_mop_schedule

  # Detect if this is a schedule-triggered cleaning
  is_schedule_trigger: >
    {{ trigger.id is defined and trigger.id.startswith('schedule_') }}

  # Conflict detection: Check if another schedule is already running
  # Only 1 schedule can be active at a time (silent abort on conflict)
  schedule_conflict_detected: >
    {% if is_schedule_trigger %}
      {# Check if robot is currently cleaning (excluding paused state) #}
      {% set is_currently_cleaning = states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states and states('sensor.' ~ vacuum_base_name ~ '_status') != paused_state %}
      {{ is_currently_cleaning }}
    {% else %}
      false
    {% endif %}

  # Current schedule trigger info (for debugging and notification context)
  schedule_trigger_map: >
    {% if trigger.id in ['schedule_map1_sweep', 'schedule_map1_mop'] %}1
    {% elif trigger.id in ['schedule_map2_sweep', 'schedule_map2_mop'] %}2
    {% elif trigger.id in ['schedule_map3_sweep', 'schedule_map3_mop'] %}3
    {% else %}unknown{% endif %}

  schedule_trigger_mode: >
    {% if trigger.id in ['schedule_map1_sweep', 'schedule_map2_sweep', 'schedule_map3_sweep'] %}sweep
    {% elif trigger.id in ['schedule_map1_mop', 'schedule_map2_mop', 'schedule_map3_mop'] %}mop
    {% else %}unknown{% endif %}

  schedule_trigger_map_name: >
    {% if trigger.id in ['schedule_map1_sweep', 'schedule_map1_mop'] %}{{ map_1_name }}
    {% elif trigger.id in ['schedule_map2_sweep', 'schedule_map2_mop'] %}{{ map_2_name }}
    {% elif trigger.id in ['schedule_map3_sweep', 'schedule_map3_mop'] %}{{ map_3_name }}
    {% else %}Unknown{% endif %}

  # ========================================
  # FUNCTION ROUTING (Hybrid: ID, Device Trigger, or MQTT Payload)
  # ========================================
  # Priority 1: User-set trigger.id
  # Priority 2: Device Trigger subtype (Zigbee2MQTT device actions)
  # Priority 3: MQTT payload fallback
  # Result: "fn_sweep", "fn_mop", "fn_start", "fn_map1", "fn_map2", "fn_map3", or "unknown"
  triggered_function: >
    {% if trigger.id is defined and trigger.id != '' %}
      {{ trigger.id }}
    {% elif trigger.platform == 'device' and trigger.subtype is defined %}
      {% set action = trigger.subtype %}
      {% if action == '1_single' %}fn_sweep
      {% elif action == '2_single' %}fn_mop
      {% elif action == '3_single' %}fn_start
      {% elif action == '4_single' %}fn_map1
      {% elif action == '5_single' %}fn_map2
      {% elif action == '6_single' %}fn_map3
      {% else %}unknown{% endif %}
    {% elif trigger.platform == 'mqtt' and trigger.payload_json is defined %}
      {% set action = trigger.payload_json.action | default('') %}
      {% if action == '1_single' %}fn_sweep
      {% elif action == '2_single' %}fn_mop
      {% elif action == '3_single' %}fn_start
      {% elif action == '4_single' %}fn_map1
      {% elif action == '5_single' %}fn_map2
      {% elif action == '6_single' %}fn_map3
      {% else %}unknown{% endif %}
    {% else %}unknown{% endif %}

  # Room/Segment Data Processing (Hybrid: supports both rooms and segments)
  # Priority 1: rooms (extract room_id values)
  # Priority 2: segments (extract segment_id or keys)
  # Room/Segment Data Processing (simplified with filters)
  # Extract room_id from rooms dict (preferred)
  room_ids: "{{ state_attr(map_camera, 'rooms').values() | map(attribute='room_id') | list if state_attr(map_camera, 'rooms') else [] }}"

  # Extract segment_id from segments dict (fallback: use keys if segment_id unavailable)
  segment_ids: "{{ state_attr(map_camera, 'segments').values() | map(attribute='segment_id') | list if state_attr(map_camera, 'segments') and state_attr(map_camera, 'segments').values() | map(attribute='segment_id') | list | length > 0 else (state_attr(map_camera, 'segments').keys() | map('int') | list if state_attr(map_camera, 'segments') else []) }}"

  # Prioritize rooms, fallback to segments, empty if neither available
  map_segments: "{{ room_ids if room_ids | length > 0 else segment_ids }}"
  has_segments: "{{ map_segments | length > 0 }}"
  segments_source: "{{ 'rooms' if room_ids | length > 0 else ('segments' if segment_ids | length > 0 else 'none') }}"

# ========================================
# ACTIONS
# ========================================
actions:
  # ========================================
  # Debug Notification (optional)
  # ========================================
  - if:
      - condition: template
        value_template: "{{ debug_mode }}"
    then:
      - action: persistent_notification.create
        data:
          title: "üìä {{ triggered_function|replace('_',' ')|title }}"
          message: |
            ‚è± {{ now().strftime('%H:%M:%S') }}

            ‚ñ∏ CURRENT STATE
            **Status:** {{ current_status }}
            **Map:** {{ current_map_name }}
            **Mode:** {{ current_mode }}
            **Cleaning:** {{ is_cleaning }} | **Paused:** {{ is_paused }}

            ‚ñ∏ TRIGGER
            **Platform:** {{ trigger.platform }}
            **ID:** {{ trigger.id | default('N/A') }}{% if trigger.platform == 'state' %}
            **Entity:** {{ trigger.entity_id | default('N/A') }}
            **State:** {{ trigger.to_state.state if trigger.to_state is defined else 'N/A' }}{% endif %}

            ‚ñ∏ CURRENT MAP CONFIG
            **Name:** {{ current_map_config.name | default('Unknown') }}
            **Repeats:** {{ current_map_config.cleaning_repeats | default(global_cleaning_repeats) }}x
            **Base:** {{ current_map_config.has_base_station | default(false) }}
            **Segments:** {{ map_segments | length }} ({{ segments_source }})

            ‚ñ∏ ALL MAPS
            ‚Ä¢ **Map 1:** {{ map_config.map_1.name }} ({{ map_config.map_1.cleaning_repeats }}x, Base: {{ map_config.map_1.has_base_station }})
            ‚Ä¢ **Map 2:** {{ map_config.map_2.name }} ({{ map_config.map_2.cleaning_repeats }}x, Base: {{ map_config.map_2.has_base_station }})
            ‚Ä¢ **Map 3:** {{ map_config.map_3.name }} ({{ map_config.map_3.cleaning_repeats }}x, Base: {{ map_config.map_3.has_base_station }})

            ‚ñ∏ SCHEDULES
            **Trigger:** {{ is_schedule_trigger }}
            **Conflict:** {{ schedule_conflict_detected }}{% if is_schedule_trigger %}
            **Target:** {{ schedule_trigger_map_name }} ({{ schedule_trigger_mode }}){% endif %}

  # ========================================
  # MAIN LOGIC - Function Routing (by trigger.id)
  # ========================================
  - choose:
      # ========================================
      # SETUP REQUIRED HANDLER
      # ========================================
      # This handles the fallback trigger and shows setup instructions
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'setup_required' }}"
        sequence:
          - action: persistent_notification.create
            data:
              title: "‚ö†Ô∏è Dreame Vacuum Blueprint - Setup Required"
              message: |
                **No functions configured!**

                Please configure your vacuum automation:

                1. **Configure at least one function:**
                   - Add triggers (State/MQTT/Event)
                   - Enable the function toggle

                2. **Available functions:**
                   - üßπ Sweep Only Mode
                   - üíß Sweep + Mop Mode
                   - ‚ñ∂Ô∏è Smart Start/Pause/Resume
                   - üó∫Ô∏è Map 1 / Map 2 / Map 3

                3. **Save your automation** after configuration

                This message appears because the automation has no active triggers configured.

      # ========================================
      # FUNCTION 1: Sweep Only Mode (fn_sweep)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_sweep' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Cleaning Mode Changed"
                  message: "Mode set to: **Sweep Only** ({{ mode_sweeping }})"

      # ========================================
      # FUNCTION 2: Sweep + Mop Mode (fn_mop)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_mop' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ mode_sweeping_mopping }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Cleaning Mode Changed"
                  message: "Mode set to: **Sweep + Mop** ({{ mode_sweeping_mopping }})"

      # ========================================
      # FUNCTION 3: Smart Start/Pause/Resume (fn_start)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_start' }}"
        sequence:
          - choose:
              # Robot is cleaning ‚Üí Pause
              - conditions:
                  - condition: template
                    value_template: "{{ is_cleaning }}"
                sequence:
                  - action: vacuum.pause
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è∏Ô∏è Robot Paused"
                          message: "‚è± {{ now().strftime('%H:%M:%S') }}\nPrevious: {{ current_status }}"

              # Robot is paused ‚Üí Resume
              - conditions:
                  - condition: template
                    value_template: "{{ is_paused }}"
                sequence:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚ñ∂Ô∏è Robot Resumed"
                          message: "‚è± {{ now().strftime('%H:%M:%S') }}\nCleaning continues"

            # Default: Robot idle ‚Üí Start Cleaning
            default:
              - choose:
                  # On base station map ‚Üí Start directly
                  - conditions:
                      - condition: template
                        value_template: "{{ is_base_station_map }}"
                    sequence:
                      # Ensure self_clean is ALWAYS ON for base station cleaning
                      # (regardless of sweep-only or sweep+mop mode)
                      - if:
                          - condition: template
                            value_template: "{{ has_value(self_clean_switch) and is_state(self_clean_switch, 'off') }}"
                        then:
                          - action: switch.turn_on
                            target:
                              entity_id: "{{ self_clean_switch }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üîß Self-Clean Enabled"
                                  message: "‚è± {{ now().strftime('%H:%M:%S') }}\nRobot can return to station during cleaning"

                      - if:
                          - condition: template
                            value_template: "{{ use_segment_service and has_segments }}"
                        then:
                          - action: dreame_vacuum.vacuum_clean_segment
                            target:
                              entity_id: "{{ vacuum_entity }}"
                            data:
                              segments: "{{ map_segments }}"
                              repeats: "{{ repeats }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üöÄ Segment Cleaning Started"
                                  message: |
                                    Map: {{ current_map_name }}
                                    Segments: {{ map_segments | length }}
                                    Repeats: {{ repeats }}
                        else:
                          - action: vacuum.start
                            target:
                              entity_id: "{{ vacuum_entity }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üöÄ Cleaning Started"
                                  message: |
                                    Map: {{ current_map_name }}
                                    Mode: Full cleaning

                # On other map ‚Üí Start and pause (for manual transport)
                default:
                  # Sweep+Mop mode: Prepare base station for mop washing
                  # For sweep-only, self_clean stays OFF (no moistening needed)
                  - if:
                      - condition: template
                        value_template: "{{ current_mode == mode_sweeping_mopping }}"
                    then:
                      # ALWAYS check and stop drying first (2h process must be aborted for immediate start)
                      - if:
                          - condition: template
                            value_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') == 'drying' }}"
                        then:
                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üõë Stopping Drying"
                                  message: "‚è± {{ now().strftime('%H:%M:%S') }}\nAborting 2h drying process..."

                          - action: button.press
                            target:
                              entity_id: "{{ stop_drying_button }}"

                          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') != 'drying' }}"
                            timeout: 10
                            continue_on_timeout: true

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "‚úÖ Drying Stopped"
                                  message: "‚è± {{ now().strftime('%H:%M:%S') }}\nStation ready for washing"

                      # Start manual mop washing (only if switch not already on)
                      - if:
                          - condition: template
                            value_template: "{{ has_value(self_clean_switch) and is_state(self_clean_switch, 'off') }}"
                        then:
                          - action: button.press
                            target:
                              entity_id: "{{ self_clean_button }}"

                          - if:
                              - condition: template
                                value_template: "{{ debug_mode }}"
                            then:
                              - action: persistent_notification.create
                                data:
                                  title: "üöø Starting Mop Washing"
                                  message: "‚è± {{ now().strftime('%H:%M:%S') }}\nManual washing triggered"

                  # Skip start if delay=0 (keep robot docked)
                  - if:
                      - condition: template
                        value_template: "{{ pause_delay_after_undock == 0 }}"
                    then:
                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è∏Ô∏è Start Skipped"
                              message: "‚è± {{ now().strftime('%H:%M:%S') }}\nDelay = 0s, robot stays docked"
                      - stop: "Delay is 0, robot stays docked"

                  # Initialize timing variables
                  - variables:
                      timing_start: "{{ now().timestamp() }}"
                      timing_start_washing: null
                      timing_start_delay: null
                      timeout_step: null

                  # Sweep+Mop: Wait for washing to complete BEFORE starting
                  - if:
                      - condition: template
                        value_template: "{{ current_mode == mode_sweeping_mopping }}"
                    then:
                      - variables:
                          timing_start_washing: "{{ now().timestamp() }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "üöø Waiting for Washing"
                              message: "‚è± {{ now().strftime('%H:%M:%S') }}\nWaiting for washing to complete..."

                      # Wait for washing status to appear
                      - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') == 'washing' }}"
                        timeout:
                          seconds: 60
                        continue_on_timeout: true

                      # Wait for washing status to end
                      - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') != 'washing' }}"
                        timeout:
                          seconds: "{{ moistening_timeout }}"
                        continue_on_timeout: true

                      - variables:
                          timing_end_washing: "{{ now().timestamp() }}"
                          duration_washing: "{{ (timing_end_washing - timing_start_washing) | round(1) }}"
                          timeout_step: "{{ 'washing' if not wait.completed and timeout_step is none else timeout_step }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "‚è±Ô∏è Timing: Washing Complete"
                              message: "‚è± {{ now().strftime('%H:%M:%S') }}\nDuration: {{ duration_washing }}s / {{ moistening_timeout }}s{{ ' (TIMEOUT)' if not wait.completed else '' }}"

                  # Start cleaning (both sweep-only and sweep+mop)
                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üöÄ Starting Cleaning"
                          message: "‚è± {{ now().strftime('%H:%M:%S') }}\nMode: {{ current_mode | replace('_', ' ') | title }}\nMap: {{ current_map_name }}"

                  - if:
                      - condition: template
                        value_template: "{{ use_segment_service and has_segments }}"
                    then:
                      - action: dreame_vacuum.vacuum_clean_segment
                        target:
                          entity_id: "{{ vacuum_entity }}"
                        data:
                          segments: "{{ map_segments }}"
                          repeats: "{{ repeats }}"
                    else:
                      - action: vacuum.start
                        target:
                          entity_id: "{{ vacuum_entity }}"

                  # Delay to allow robot to move away from station
                  - variables:
                      timing_start_delay: "{{ now().timestamp() }}"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è±Ô∏è Delay Timer Started"
                          message: "‚è± {{ now().strftime('%H:%M:%S') }}\nWaiting {{ pause_delay_after_undock }}s for robot movement..."

                  - delay:
                      seconds: "{{ pause_delay_after_undock }}"

                  - variables:
                      timing_end_delay: "{{ now().timestamp() }}"
                      duration_delay: "{{ (timing_end_delay - timing_start_delay) | round(1) }}"

                  # Pause for manual transport
                  - action: vacuum.pause
                    target:
                      entity_id: "{{ vacuum_entity }}"

                  # Disable self_clean after pause (robot should not return to station)
                  - if:
                      - condition: template
                        value_template: "{{ has_value(self_clean_switch) and is_state(self_clean_switch, 'on') }}"
                    then:
                      - action: switch.turn_off
                        target:
                          entity_id: "{{ self_clean_switch }}"

                      - if:
                          - condition: template
                            value_template: "{{ debug_mode }}"
                        then:
                          - action: persistent_notification.create
                            data:
                              title: "üîß Self-Clean Disabled"
                              message: "‚è± {{ now().strftime('%H:%M:%S') }}\nRobot will not return to station"

                  - if:
                      - condition: template
                        value_template: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "‚è∏Ô∏è Robot Paused for Transport"
                          message: "‚è± {{ now().strftime('%H:%M:%S') }}\nMap: {{ current_map_name }}\nTransport robot & press button to resume"

                      # Timing Summary
                      - action: persistent_notification.create
                        data:
                          title: "üìä Timing Summary"
                          message: |
                            ‚è± {{ now().strftime('%H:%M:%S') }}
                            {% if timing_start_washing is not none %}
                            ‚Ä¢ Washing: {{ duration_washing }}s / {{ moistening_timeout }}s{{ ' (TIMEOUT)' if timeout_step == 'washing' else '' }}
                            {% endif %}
                            {% if timing_start_delay is not none %}
                            ‚Ä¢ Delay: {{ duration_delay }}s
                            {% endif %}
                            Total: {{ (now().timestamp() - timing_start) | round(1) }}s

      # ========================================
      # FUNCTION 4: Map 1 Switch (fn_map1)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map1' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_1_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_1_name }}**"

      # ========================================
      # FUNCTION 5: Map 2 Switch (fn_map2)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map2' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_2_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_2_name }}**"

      # ========================================
      # FUNCTION 6: Map 3 Switch (fn_map3)
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ triggered_function == 'fn_map3' }}"
        sequence:
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ map_3_name }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üó∫Ô∏è Map Changed"
                  message: "New Map: **{{ map_3_name }}**"

      # ========================================
      # SCHEDULE-TRIGGERED CLEANING FUNCTIONS
      # ========================================
      # These functions are triggered by schedule entities (state: "on")
      # Workflow:
      # 1. Conflict check (abort if already cleaning)
      # 2. If map has base station ‚Üí Start cleaning immediately
      # 3. If map WITHOUT base station ‚Üí Send notification, wait for user action

      # ========================================
      # SCHEDULE 1: Map 1 Sweep Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map1_sweep' and map_1_sweep_schedule_entity != 'none' }}"
        sequence:
          # Extract map number and mode from trigger for dynamic lookups
          - variables:
              map_number: 1
              target_mode: "{{ mode_sweeping }}"
              target_map_name: "{{ map_1_name }}"
              target_map_config: "{{ map_config.map_1 }}"
              schedule_label: "Map 1 Sweep"

          # Conflict check: Abort if already cleaning
          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          # Set mode and switch map
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ target_mode }}"

          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ target_map_name }}"

          - wait_template: "{{ states(selected_map_select) == target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Start cleaning if base station map, otherwise notify
          - if: "{{ target_map_config.has_base_station }}"
            then:
              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        actions:
                          - action: "PREPARE_MAP1_SWEEP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # SCHEDULE 2: Map 1 Mop Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map1_mop' and map_1_mop_schedule_entity != 'none' }}"
        sequence:
          - variables:
              map_number: 1
              target_mode: "{{ mode_sweeping_mopping }}"
              target_map_name: "{{ map_1_name }}"
              target_map_config: "{{ map_config.map_1 }}"
              schedule_label: "Map 1 Mop"

          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ target_mode }}"

          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ target_map_name }}"

          - wait_template: "{{ states(selected_map_select) == target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          - if: "{{ target_map_config.has_base_station }}"
            then:
              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        actions:
                          - action: "PREPARE_MAP1_MOP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # SCHEDULE 3: Map 2 Sweep Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map2_sweep' and map_2_sweep_schedule_entity != 'none' }}"
        sequence:
          - variables:
              map_number: 2
              target_mode: "{{ mode_sweeping }}"
              target_map_name: "{{ map_2_name }}"
              target_map_config: "{{ map_config.map_2 }}"
              schedule_label: "Map 2 Sweep"

          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ target_mode }}"

          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ target_map_name }}"

          - wait_template: "{{ states(selected_map_select) == target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          - if: "{{ target_map_config.has_base_station }}"
            then:
              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        actions:
                          - action: "PREPARE_MAP2_SWEEP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # SCHEDULE 4: Map 2 Mop Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map2_mop' and map_2_mop_schedule_entity != 'none' }}"
        sequence:
          - variables:
              map_number: 2
              target_mode: "{{ mode_sweeping_mopping }}"
              target_map_name: "{{ map_2_name }}"
              target_map_config: "{{ map_config.map_2 }}"
              schedule_label: "Map 2 Mop"

          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ target_mode }}"

          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ target_map_name }}"

          - wait_template: "{{ states(selected_map_select) == target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          - if: "{{ target_map_config.has_base_station }}"
            then:
              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        actions:
                          - action: "PREPARE_MAP2_MOP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # SCHEDULE 5: Map 3 Sweep Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map3_sweep' and map_3_sweep_schedule_entity != 'none' }}"
        sequence:
          - variables:
              map_number: 3
              target_mode: "{{ mode_sweeping }}"
              target_map_name: "{{ map_3_name }}"
              target_map_config: "{{ map_config.map_3 }}"
              schedule_label: "Map 3 Sweep"

          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ target_mode }}"

          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ target_map_name }}"

          - wait_template: "{{ states(selected_map_select) == target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          - if: "{{ target_map_config.has_base_station }}"
            then:
              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        actions:
                          - action: "PREPARE_MAP3_SWEEP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # SCHEDULE 6: Map 3 Mop Schedule
      # ========================================
      - conditions: "{{ trigger.id == 'schedule_map3_mop' and map_3_mop_schedule_entity != 'none' }}"
        sequence:
          - variables:
              map_number: 3
              target_mode: "{{ mode_sweeping_mopping }}"
              target_map_name: "{{ map_3_name }}"
              target_map_config: "{{ map_config.map_3 }}"
              schedule_label: "Map 3 Mop"

          - if: "{{ schedule_conflict_detected }}"
            then:
              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚ö†Ô∏è Schedule Conflict"
                      message: "{{ schedule_label }} skipped - robot already cleaning"
              - stop: "Schedule conflict"

          - if: "{{ target_map_config.has_base_station }}"
            then:
              # Base station map ‚Üí Start cleaning immediately
              - action: select.select_option
                target:
                  entity_id: "{{ cleaning_mode_select }}"
                data:
                  option: "{{ target_mode }}"

              - action: select.select_option
                target:
                  entity_id: "{{ selected_map_select }}"
                data:
                  option: "{{ target_map_name }}"

              - wait_template: "{{ states(selected_map_select) == target_map_name }}"
                timeout: 30
                continue_on_timeout: false

              - if: "{{ use_segment_service and has_segments }}"
                then:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ map_segments }}"
                      repeats: "{{ target_map_config.cleaning_repeats }}"
                else:
                  - action: vacuum.start
                    target:
                      entity_id: "{{ vacuum_entity }}"

              - if: "{{ debug_mode }}"
                then:
                  - action: persistent_notification.create
                    data:
                      title: "‚úÖ Schedule Started"
                      message: "{{ schedule_label }} on base station map"
            else:
              # Map WITHOUT base station ‚Üí Send notification
              - if: "{{ scheduled_notification_enabled }}"
                then:
                  # Define template variables for notification
                  - variables:
                      map_name: "{{ target_map_name }}"
                      schedule_name: "{{ schedule_label }}"
                      cleaning_mode_display: >
                        {% if target_mode == mode_sweeping %}{{ sweep_display }}
                        {% elif target_mode == mode_sweeping_mopping %}{{ sweep_mop_display }}
                        {% else %}{{ target_mode }}{% endif %}
                  # Send actionable notification with buttons
                  - action: !input scheduled_notification_service
                    data:
                      title: !input scheduled_notification_title
                      message: !input scheduled_notification_message
                      data:
                        # Action buttons
                        actions:
                          - action: "PREPARE_MAP3_MOP"
                            title: "{{ prepare_button }}"
                          - action: "SKIP_CLEANING"
                            title: "{{ skip_button }}"
                        # iOS Push Settings for Lock Screen
                        push:
                          interruption-level: "{{ scheduled_notification_interruption_level }}"
                          sound: >
                            {% if scheduled_notification_critical %}
                              {
                                "name": "{{ scheduled_notification_sound }}",
                                "critical": 1,
                                "volume": {{ scheduled_notification_volume }}
                              }
                            {% else %}
                              "{{ scheduled_notification_sound }}"
                            {% endif %}

                  - if: "{{ debug_mode }}"
                    then:
                      - action: persistent_notification.create
                        data:
                          title: "üîî Notification Sent"
                          message: "Waiting for preparation: {{ schedule_label }}"

      # ========================================
      # NOTIFICATION ACTION HANDLERS
      # ========================================
      # These handle user responses from notification action buttons

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 1 Sweep
      # ========================================
      # Preparation workflow for maps without base station (Sweep Only)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (for consistency)
      # 3. Set cleaning mode
      # 4. [SKIP mop washing - sweep-only mode]
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map1_sweep' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping }}"
              notification_target_map_name: "{{ map_1_name }}"
              notification_cleaning_repeats: "{{ map_config.map_1.cleaning_repeats }}"
              schedule_label: "Map 1 Sweep"

          # Professional debug notification: Workflow started
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map1"
                  notification_id: "vacuum_prepare_map1_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Start cleaning
                    4. Pause after {{ pause_delay_after_undock }}s
                    5. Switch map
                    6. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (for consistency, even though sweep mode doesn't use mops)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: [SKIP mop washing - this is sweep-only mode]

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification with action buttons
          - if: "{{ pickup_notification_enabled }}"
            then:
              # Define template variables for notification
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    # iOS Push Settings
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map1"
                  notification_id: "vacuum_prepare_map1_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 1 Mop
      # ========================================
      # Preparation workflow for maps without base station (Sweep & Mop)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (prevents auto-return during cleaning)
      # 3. Set cleaning mode
      # 4. Manual mop washing with button press
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map1_mop' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping_mopping }}"
              notification_target_map_name: "{{ map_1_name }}"
              notification_cleaning_repeats: "{{ map_config.map_1.cleaning_repeats }}"
              schedule_label: "Map 1 Mop"

          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map1"
                  notification_id: "vacuum_prepare_map1_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Mop washing (~3min)
                    4. Start cleaning
                    5. Pause after {{ pause_delay_after_undock }}s
                    6. Switch map
                    7. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (prevents auto-return during cleaning)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: Manual mop washing (controlled preparation)
          - action: button.press
            target:
              entity_id: "button.{{ vacuum_base_name }}_self_clean"
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') in ['washing', 'clean_add_water'] }}"
            timeout: 60
            continue_on_timeout: false
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') not in ['washing', 'clean_add_water'] }}"
            timeout: 180
            continue_on_timeout: false

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification
          - if: "{{ pickup_notification_enabled }}"
            then:
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map1"
                  notification_id: "vacuum_prepare_map1_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 2 Sweep
      # ========================================
      # Preparation workflow for maps without base station (Sweep Only)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (for consistency)
      # 3. Set cleaning mode
      # 4. [SKIP mop washing - sweep-only mode]
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map2_sweep' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping }}"
              notification_target_map_name: "{{ map_2_name }}"
              notification_cleaning_repeats: "{{ map_config.map_2.cleaning_repeats }}"
              schedule_label: "Map 2 Sweep"

          # Professional debug notification: Workflow started
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map2"
                  notification_id: "vacuum_prepare_map2_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Start cleaning
                    4. Pause after {{ pause_delay_after_undock }}s
                    5. Switch map
                    6. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (for consistency, even though sweep mode doesn't use mops)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: [SKIP mop washing - this is sweep-only mode]

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification with action buttons
          - if: "{{ pickup_notification_enabled }}"
            then:
              # Define template variables for notification
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    # iOS Push Settings
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map2"
                  notification_id: "vacuum_prepare_map2_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 2 Mop
      # ========================================
      # Preparation workflow for maps without base station (Sweep & Mop)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (prevents auto-return during cleaning)
      # 3. Set cleaning mode
      # 4. Manual mop washing with button press
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map2_mop' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping_mopping }}"
              notification_target_map_name: "{{ map_2_name }}"
              notification_cleaning_repeats: "{{ map_config.map_2.cleaning_repeats }}"
              schedule_label: "Map 2 Mop"

          # Professional debug notification: Workflow started
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map2"
                  notification_id: "vacuum_prepare_map2_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Mop washing (~3min)
                    4. Start cleaning
                    5. Pause after {{ pause_delay_after_undock }}s
                    6. Switch map
                    7. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (prevents auto-return during cleaning)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: Manual mop washing (controlled preparation)
          - action: button.press
            target:
              entity_id: "button.{{ vacuum_base_name }}_self_clean"
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') in ['washing', 'clean_add_water'] }}"
            timeout: 60
            continue_on_timeout: false
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') not in ['washing', 'clean_add_water'] }}"
            timeout: 180
            continue_on_timeout: false

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification with action buttons
          - if: "{{ pickup_notification_enabled }}"
            then:
              # Define template variables for notification
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    # iOS Push Settings
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map2"
                  notification_id: "vacuum_prepare_map2_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 3 Sweep
      # ========================================
      # Preparation workflow for maps without base station (Sweep Only)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (for consistency)
      # 3. Set cleaning mode
      # 4. [SKIP mop washing - sweep-only mode]
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map3_sweep' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping }}"
              notification_target_map_name: "{{ map_3_name }}"
              notification_cleaning_repeats: "{{ map_config.map_3.cleaning_repeats }}"
              schedule_label: "Map 3 Sweep"

          # Professional debug notification: Workflow started
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map3"
                  notification_id: "vacuum_prepare_map3_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Start cleaning
                    4. Pause after {{ pause_delay_after_undock }}s
                    5. Switch map
                    6. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (for consistency, even though sweep mode doesn't use mops)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: [SKIP mop washing - this is sweep-only mode]

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification with action buttons
          - if: "{{ pickup_notification_enabled }}"
            then:
              # Define template variables for notification
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    # iOS Push Settings
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map3"
                  notification_id: "vacuum_prepare_map3_sweep"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Prepare Robot - Map 3 Mop
      # ========================================
      # Preparation workflow for maps without base station (Sweep & Mop)
      # 1. Disable customized_cleaning (enables global mode settings)
      # 2. Save & disable self_clean (prevents auto-return during cleaning)
      # 3. Set cleaning mode
      # 4. Manual mop washing with button press
      # 5. Start segment cleaning
      # 6. Pause after delay
      # 7. Switch to target map
      # 8. Restore settings after map switch
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_prepare_map3_mop' }}"
        sequence:
          - variables:
              notification_target_mode: "{{ mode_sweeping_mopping }}"
              notification_target_map_name: "{{ map_3_name }}"
              notification_cleaning_repeats: "{{ map_config.map_3.cleaning_repeats }}"
              schedule_label: "Map 3 Mop"

          # Professional debug notification: Workflow started
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚öôÔ∏è Prepare Map3"
                  notification_id: "vacuum_prepare_map3_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Repeats:** {{ notification_cleaning_repeats }}x

                    **Workflow**
                    1. Disable custom_clean
                    2. Set mode
                    3. Mop washing (~3min)
                    4. Start cleaning
                    5. Pause after {{ pause_delay_after_undock }}s
                    6. Switch map
                    7. Restore settings

                    ‚è≥ In Progress...

          # Step 1: Disable customized_cleaning (enables global cleaning_mode_select)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"
          - wait_template: "{{ is_state('switch.' ~ vacuum_base_name ~ '_customized_cleaning', 'off') }}"
            timeout: 10
            continue_on_timeout: false

          # Step 2: Save & disable self_clean (prevents auto-return during cleaning)
          - variables:
              original_self_clean_state: "{{ states('switch.' ~ vacuum_base_name ~ '_self_clean') }}"
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 3: Set cleaning mode
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 4: Manual mop washing (controlled preparation)
          - action: button.press
            target:
              entity_id: "button.{{ vacuum_base_name }}_self_clean"
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') in ['washing', 'clean_add_water'] }}"
            timeout: 60
            continue_on_timeout: false
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_self_wash_base_status') not in ['washing', 'clean_add_water'] }}"
            timeout: 180
            continue_on_timeout: false

          # Step 5: Extract segments & start cleaning
          - variables:
              notification_map_segments: >-
                {% set map_camera = 'camera.' ~ vacuum_base_name ~ '_map' %}
                {% if states(map_camera) not in ['unknown', 'unavailable'] %}
                  {% if state_attr(map_camera, 'rooms') is not none %}
                    {{ state_attr(map_camera, 'rooms').keys() | map('int') | list }}
                  {% elif state_attr(map_camera, 'segments') is not none %}
                    {{ state_attr(map_camera, 'segments').keys() | map('int') | list }}
                  {% else %}
                    []
                  {% endif %}
                {% else %}
                  []
                {% endif %}

          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_segment_service }}"
                  - condition: template
                    value_template: "{{ notification_map_segments | length > 0 }}"
                sequence:
                  - action: dreame_vacuum.vacuum_clean_segment
                    target:
                      entity_id: "{{ vacuum_entity }}"
                    data:
                      segments: "{{ notification_map_segments }}"
                      repeats: "{{ notification_cleaning_repeats }}"
            default:
              - action: vacuum.start
                target:
                  entity_id: "{{ vacuum_entity }}"

          # Step 6: Wait for cleaning state, delay, then pause
          - wait_template: "{{ states('sensor.' ~ vacuum_base_name ~ '_status') in cleaning_states }}"
            timeout: 120
            continue_on_timeout: false
          # Optional delay before pause (prevents wet floors before base station)
          - if: "{{ pause_delay_after_undock > 0 }}"
            then:
              - delay:
                  seconds: "{{ pause_delay_after_undock }}"
          # Pause for manual transport
          - action: vacuum.pause
            target:
              entity_id: "{{ vacuum_entity }}"

          # Step 7: Switch to target map
          - action: select.select_option
            target:
              entity_id: "{{ selected_map_select }}"
            data:
              option: "{{ notification_target_map_name }}"
          - wait_template: "{{ states(selected_map_select) == notification_target_map_name }}"
            timeout: 30
            continue_on_timeout: false

          # Step 8: Re-disable customized_cleaning (map switch re-enables it)
          - action: switch.turn_off
            target:
              entity_id: "switch.{{ vacuum_base_name }}_customized_cleaning"

          # Step 9: Re-set cleaning mode (map switch overwrites it)
          - action: select.select_option
            target:
              entity_id: "{{ cleaning_mode_select }}"
            data:
              option: "{{ notification_target_mode }}"

          # Step 10: Restore self_clean to original state
          - action: "switch.turn_{{ original_self_clean_state }}"
            target:
              entity_id: "switch.{{ vacuum_base_name }}_self_clean"

          # Step 11: Send pickup notification with action buttons
          - if: "{{ pickup_notification_enabled }}"
            then:
              # Define template variables for notification
              - variables:
                  map_name: "{{ notification_target_map_name }}"
                  current_map: "{{ states(selected_map_select) }}"
              - action: !input pickup_notification_service
                data:
                  title: !input pickup_notification_title
                  message: !input pickup_notification_message
                  data:
                    actions:
                      - action: "START_CLEANING"
                        title: "{{ start_cleaning_button }}"
                      - action: "CANCEL_CLEANING"
                        title: "{{ cancel_cleaning_button }}"
                    # iOS Push Settings
                    push:
                      interruption-level: "{{ pickup_notification_interruption_level }}"
                      sound: >
                        {% if pickup_notification_critical %}
                          {
                            "name": "{{ pickup_notification_sound }}",
                            "critical": 1,
                            "volume": {{ pickup_notification_volume }}
                          }
                        {% else %}
                          "{{ pickup_notification_sound }}"
                        {% endif %}

          # Debug: Completion notification
          - if: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ Complete Map3"
                  notification_id: "vacuum_prepare_map3_mop"
                  message: |
                    ‚è± {{ now().strftime('%H:%M:%S') }}
                    **Map:** {{ notification_target_map_name }}
                    **Mode:** {{ notification_target_mode }}
                    **Status:** Paused & Ready üéØ

                    üöö Transport to target map and resume

      # ========================================
      # NOTIFICATION ACTION: Skip Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_skip' }}"
        sequence:
          # Skip this scheduled cleaning - no action needed
          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚è≠Ô∏è Scheduled Cleaning Skipped"
                  message: "User skipped scheduled cleaning via notification button."

      # ========================================
      # EMERGENCY WATCH: Unexpected Cleaning Start
      # ========================================
      # Validates map selection when cleaning starts outside our workflow
      # Pauses robot if selected map is not one of our configured maps
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'emergency_watch' }}"
        sequence:
          # Safety check: Validate selected map
          - if:
              - condition: template
                value_template: "{{ states(selected_map_select) not in [map_1_name, map_2_name, map_3_name] }}"
            then:
              # Invalid map ‚Üí Emergency pause
              - action: vacuum.pause
                target:
                  entity_id: "{{ vacuum_entity }}"

              - action: persistent_notification.create
                data:
                  title: "‚ö†Ô∏è EMERGENCY: Invalid Map"
                  notification_id: "vacuum_emergency_pause"
                  message: |
                    **Cleaning paused automatically**

                    **Current Map:** {{ states(selected_map_select) }}
                    **Configured Maps:**
                    ‚Ä¢ {{ map_1_name }}
                    ‚Ä¢ {{ map_2_name }}
                    ‚Ä¢ {{ map_3_name }}

                    **Action Required:**
                    1. Use Schedule workflow (auto-prepares robot)
                    2. OR: Use PREPARE workflow for manual transport
                    3. OR: Switch to correct map before starting

              - stop: "Emergency pause - invalid map selected"

          # Map is valid ‚Üí Continue (external start on valid map)
          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚úÖ External Start (Map Valid)"
                  notification_id: "vacuum_external_start"
                  message: |
                    **Cleaning started externally**

                    **Map:** {{ states(selected_map_select) }}
                    **Status:** {{ states('sensor.' ~ vacuum_base_name ~ '_status') }}
                    **Source:** Outside blueprint workflow

      # ========================================
      # NOTIFICATION ACTION: Start Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_start' }}"
        sequence:
          # Resume cleaning after transport
          - action: vacuum.start
            target:
              entity_id: "{{ vacuum_entity }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "‚ñ∂Ô∏è Cleaning Resumed"
                  message: "Robot resumed cleaning after transport."

      # ========================================
      # NOTIFICATION ACTION: Cancel Cleaning
      # ========================================
      - conditions:
          - condition: template
            value_template: "{{ trigger.id == 'notification_cancel' }}"
        sequence:
          # Check if robot is on base station map
          - choose:
              # If NOT on base station map, switch to it
              - conditions:
                  - condition: template
                    value_template: "{{ current_map_name != base_station_map }}"
                sequence:
                  - action: select.select_option
                    target:
                      entity_id: "{{ selected_map_select }}"
                    data:
                      option: "{{ base_station_map }}"

                  - wait_template: "{{ states(selected_map_select) == base_station_map }}"
                    timeout: 30
                    continue_on_timeout: true

          # Return to dock
          - action: vacuum.return_to_base
            target:
              entity_id: "{{ vacuum_entity }}"

          - if:
              - condition: template
                value_template: "{{ debug_mode }}"
            then:
              - action: persistent_notification.create
                data:
                  title: "üè† Returning to Base"
                  message: "Robot cancelled cleaning and returning to base station."

    # Default: Unknown trigger ID (should not happen)
    default:
      - if:
          - condition: template
            value_template: "{{ debug_mode }}"
        then:
          - action: persistent_notification.create
            data:
              title: "‚ö†Ô∏è Unknown Trigger ID"
              message: |
                **Triggered Function:** {{ triggered_function }}
                **Trigger Platform:** {{ trigger.platform }}
                **Trigger Entity:** {{ trigger.entity_id | default('N/A') }}

                This trigger ID is not configured. Please check your function trigger configurations.

# ========================================
# AUTOMATION MODE
# ========================================
mode: queued
max: 10
max_exceeded: silent
